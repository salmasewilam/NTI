
NTI_AVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000df4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000004  00800060  00000df4  00000e88  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000018  00800064  00800064  00000e8c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e8c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000ebc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000448  00000000  00000000  00000ef8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004531  00000000  00000000  00001340  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000015d5  00000000  00000000  00005871  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000023c5  00000000  00000000  00006e46  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ca4  00000000  00000000  0000920c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000013b5  00000000  00000000  00009eb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000024eb  00000000  00000000  0000b265  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003c8  00000000  00000000  0000d750  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3a 00 	jmp	0x74	; 0x74 <__ctors_end>
   4:	0c 94 91 04 	jmp	0x922	; 0x922 <__vector_1>
   8:	0c 94 ba 04 	jmp	0x974	; 0x974 <__vector_2>
   c:	0c 94 e3 04 	jmp	0x9c6	; 0x9c6 <__vector_3>
  10:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
  14:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
  18:	0c 94 36 06 	jmp	0xc6c	; 0xc6c <__vector_6>
  1c:	0c 94 e4 05 	jmp	0xbc8	; 0xbc8 <__vector_7>
  20:	0c 94 0d 06 	jmp	0xc1a	; 0xc1a <__vector_8>
  24:	0c 94 bb 05 	jmp	0xb76	; 0xb76 <__vector_9>
  28:	0c 94 92 05 	jmp	0xb24	; 0xb24 <__vector_10>
  2c:	0c 94 69 05 	jmp	0xad2	; 0xad2 <__vector_11>
  30:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
  34:	0c 94 5f 06 	jmp	0xcbe	; 0xcbe <__vector_13>
  38:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
  3c:	0c 94 88 06 	jmp	0xd10	; 0xd10 <__vector_15>
  40:	0c 94 ec 03 	jmp	0x7d8	; 0x7d8 <__vector_16>
  44:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
  48:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
  4c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
  50:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
  54:	21 04       	cpc	r2, r1
  56:	27 04       	cpc	r2, r7
  58:	2d 04       	cpc	r2, r13
  5a:	33 04       	cpc	r3, r3
  5c:	39 04       	cpc	r3, r9
  5e:	3f 04       	cpc	r3, r15
  60:	45 04       	cpc	r4, r5
  62:	4b 04       	cpc	r4, r11
  64:	5f 04       	cpc	r5, r15
  66:	65 04       	cpc	r6, r5
  68:	6b 04       	cpc	r6, r11
  6a:	71 04       	cpc	r7, r1
  6c:	77 04       	cpc	r7, r7
  6e:	7d 04       	cpc	r7, r13
  70:	83 04       	cpc	r8, r3
  72:	89 04       	cpc	r8, r9

00000074 <__ctors_end>:
  74:	11 24       	eor	r1, r1
  76:	1f be       	out	0x3f, r1	; 63
  78:	cf e5       	ldi	r28, 0x5F	; 95
  7a:	d8 e0       	ldi	r29, 0x08	; 8
  7c:	de bf       	out	0x3e, r29	; 62
  7e:	cd bf       	out	0x3d, r28	; 61

00000080 <__do_copy_data>:
  80:	10 e0       	ldi	r17, 0x00	; 0
  82:	a0 e6       	ldi	r26, 0x60	; 96
  84:	b0 e0       	ldi	r27, 0x00	; 0
  86:	e4 ef       	ldi	r30, 0xF4	; 244
  88:	fd e0       	ldi	r31, 0x0D	; 13
  8a:	02 c0       	rjmp	.+4      	; 0x90 <__do_copy_data+0x10>
  8c:	05 90       	lpm	r0, Z+
  8e:	0d 92       	st	X+, r0
  90:	a4 36       	cpi	r26, 0x64	; 100
  92:	b1 07       	cpc	r27, r17
  94:	d9 f7       	brne	.-10     	; 0x8c <__do_copy_data+0xc>

00000096 <__do_clear_bss>:
  96:	20 e0       	ldi	r18, 0x00	; 0
  98:	a4 e6       	ldi	r26, 0x64	; 100
  9a:	b0 e0       	ldi	r27, 0x00	; 0
  9c:	01 c0       	rjmp	.+2      	; 0xa0 <.do_clear_bss_start>

0000009e <.do_clear_bss_loop>:
  9e:	1d 92       	st	X+, r1

000000a0 <.do_clear_bss_start>:
  a0:	ac 37       	cpi	r26, 0x7C	; 124
  a2:	b2 07       	cpc	r27, r18
  a4:	e1 f7       	brne	.-8      	; 0x9e <.do_clear_bss_loop>
  a6:	0e 94 9a 03 	call	0x734	; 0x734 <main>
  aa:	0c 94 f8 06 	jmp	0xdf0	; 0xdf0 <_exit>

000000ae <__bad_interrupt>:
  ae:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b2 <sevseg_init>:
#include <util/delay.h>
	
void sevseg_init(void)
{
	//set com as output for the four 7seg
	DIO_voidSetPinDirection(ptrA,2,1);
  b2:	41 e0       	ldi	r20, 0x01	; 1
  b4:	62 e0       	ldi	r22, 0x02	; 2
  b6:	89 e3       	ldi	r24, 0x39	; 57
  b8:	90 e0       	ldi	r25, 0x00	; 0
  ba:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(ptrA,3,1);
  be:	41 e0       	ldi	r20, 0x01	; 1
  c0:	63 e0       	ldi	r22, 0x03	; 3
  c2:	89 e3       	ldi	r24, 0x39	; 57
  c4:	90 e0       	ldi	r25, 0x00	; 0
  c6:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(ptrB,5,1);
  ca:	41 e0       	ldi	r20, 0x01	; 1
  cc:	65 e0       	ldi	r22, 0x05	; 5
  ce:	86 e3       	ldi	r24, 0x36	; 54
  d0:	90 e0       	ldi	r25, 0x00	; 0
  d2:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(ptrB,6,1);
  d6:	41 e0       	ldi	r20, 0x01	; 1
  d8:	66 e0       	ldi	r22, 0x06	; 6
  da:	86 e3       	ldi	r24, 0x36	; 54
  dc:	90 e0       	ldi	r25, 0x00	; 0
  de:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	
    //enable only one 7seg
	DIO_voidSetPinValue(ptrA,2,1);
  e2:	41 e0       	ldi	r20, 0x01	; 1
  e4:	62 e0       	ldi	r22, 0x02	; 2
  e6:	89 e3       	ldi	r24, 0x39	; 57
  e8:	90 e0       	ldi	r25, 0x00	; 0
  ea:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(ptrA,3,0);
  ee:	40 e0       	ldi	r20, 0x00	; 0
  f0:	63 e0       	ldi	r22, 0x03	; 3
  f2:	89 e3       	ldi	r24, 0x39	; 57
  f4:	90 e0       	ldi	r25, 0x00	; 0
  f6:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(ptrB,5,1);
  fa:	41 e0       	ldi	r20, 0x01	; 1
  fc:	65 e0       	ldi	r22, 0x05	; 5
  fe:	86 e3       	ldi	r24, 0x36	; 54
 100:	90 e0       	ldi	r25, 0x00	; 0
 102:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(ptrB,6,1);
 106:	41 e0       	ldi	r20, 0x01	; 1
 108:	66 e0       	ldi	r22, 0x06	; 6
 10a:	86 e3       	ldi	r24, 0x36	; 54
 10c:	90 e0       	ldi	r25, 0x00	; 0
 10e:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
	
	//set decoder pins as output
	DIO_voidSetPinDirection(ptrB,0,1);
 112:	41 e0       	ldi	r20, 0x01	; 1
 114:	60 e0       	ldi	r22, 0x00	; 0
 116:	86 e3       	ldi	r24, 0x36	; 54
 118:	90 e0       	ldi	r25, 0x00	; 0
 11a:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(ptrB,1,1);
 11e:	41 e0       	ldi	r20, 0x01	; 1
 120:	61 e0       	ldi	r22, 0x01	; 1
 122:	86 e3       	ldi	r24, 0x36	; 54
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(ptrB,2,1);
 12a:	41 e0       	ldi	r20, 0x01	; 1
 12c:	62 e0       	ldi	r22, 0x02	; 2
 12e:	86 e3       	ldi	r24, 0x36	; 54
 130:	90 e0       	ldi	r25, 0x00	; 0
 132:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(ptrB,4,1);
 136:	41 e0       	ldi	r20, 0x01	; 1
 138:	64 e0       	ldi	r22, 0x04	; 4
 13a:	86 e3       	ldi	r24, 0x36	; 54
 13c:	90 e0       	ldi	r25, 0x00	; 0
 13e:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
 142:	08 95       	ret

00000144 <keypad_init>:
{'M','N','O','S'}
};
void keypad_init (void)
{
	//set output pins rows
	DIO_voidSetPinDirection(PORT_OUT,FIRST_OUTPUT,OUTPUT);
 144:	41 e0       	ldi	r20, 0x01	; 1
 146:	64 e0       	ldi	r22, 0x04	; 4
 148:	86 e3       	ldi	r24, 0x36	; 54
 14a:	90 e0       	ldi	r25, 0x00	; 0
 14c:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PORT_OUT,SECOND_OUTPUT,OUTPUT);
 150:	41 e0       	ldi	r20, 0x01	; 1
 152:	65 e0       	ldi	r22, 0x05	; 5
 154:	86 e3       	ldi	r24, 0x36	; 54
 156:	90 e0       	ldi	r25, 0x00	; 0
 158:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PORT_OUT,THIRD_OUTPUT,OUTPUT);
 15c:	41 e0       	ldi	r20, 0x01	; 1
 15e:	66 e0       	ldi	r22, 0x06	; 6
 160:	86 e3       	ldi	r24, 0x36	; 54
 162:	90 e0       	ldi	r25, 0x00	; 0
 164:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PORT_OUT,FORTH_OUTPUT,OUTPUT);
 168:	41 e0       	ldi	r20, 0x01	; 1
 16a:	67 e0       	ldi	r22, 0x07	; 7
 16c:	86 e3       	ldi	r24, 0x36	; 54
 16e:	90 e0       	ldi	r25, 0x00	; 0
 170:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	//set input pins cols
	DIO_voidSetPinDirection(PORT_IN,FIRST_INPUT,INPUT);
 174:	40 e0       	ldi	r20, 0x00	; 0
 176:	62 e0       	ldi	r22, 0x02	; 2
 178:	80 e3       	ldi	r24, 0x30	; 48
 17a:	90 e0       	ldi	r25, 0x00	; 0
 17c:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PORT_IN,SECOND_INPUT,INPUT);
 180:	40 e0       	ldi	r20, 0x00	; 0
 182:	63 e0       	ldi	r22, 0x03	; 3
 184:	80 e3       	ldi	r24, 0x30	; 48
 186:	90 e0       	ldi	r25, 0x00	; 0
 188:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PORT_IN,THIRD_INPUT,INPUT);
 18c:	40 e0       	ldi	r20, 0x00	; 0
 18e:	64 e0       	ldi	r22, 0x04	; 4
 190:	80 e3       	ldi	r24, 0x30	; 48
 192:	90 e0       	ldi	r25, 0x00	; 0
 194:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PORT_IN,FORTH_INPUT,INPUT);
 198:	40 e0       	ldi	r20, 0x00	; 0
 19a:	65 e0       	ldi	r22, 0x05	; 5
 19c:	80 e3       	ldi	r24, 0x30	; 48
 19e:	90 e0       	ldi	r25, 0x00	; 0
 1a0:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	//set output as high
	DIO_voidSetPinValue(PORT_OUT,FIRST_OUTPUT,HIGH);
 1a4:	41 e0       	ldi	r20, 0x01	; 1
 1a6:	64 e0       	ldi	r22, 0x04	; 4
 1a8:	86 e3       	ldi	r24, 0x36	; 54
 1aa:	90 e0       	ldi	r25, 0x00	; 0
 1ac:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(PORT_OUT,SECOND_OUTPUT,HIGH);
 1b0:	41 e0       	ldi	r20, 0x01	; 1
 1b2:	65 e0       	ldi	r22, 0x05	; 5
 1b4:	86 e3       	ldi	r24, 0x36	; 54
 1b6:	90 e0       	ldi	r25, 0x00	; 0
 1b8:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(PORT_OUT,SECOND_OUTPUT,HIGH);
 1bc:	41 e0       	ldi	r20, 0x01	; 1
 1be:	65 e0       	ldi	r22, 0x05	; 5
 1c0:	86 e3       	ldi	r24, 0x36	; 54
 1c2:	90 e0       	ldi	r25, 0x00	; 0
 1c4:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(PORT_OUT,SECOND_OUTPUT,HIGH);
 1c8:	41 e0       	ldi	r20, 0x01	; 1
 1ca:	65 e0       	ldi	r22, 0x05	; 5
 1cc:	86 e3       	ldi	r24, 0x36	; 54
 1ce:	90 e0       	ldi	r25, 0x00	; 0
 1d0:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
 1d4:	08 95       	ret

000001d6 <H_LCD_void_latchByte>:
	{
		H_LCD_void_sendCommand(0x80|copy_u8Col);
	}
	else if (copy_u8Row ==1)
	{
		H_LCD_void_sendCommand(0x80+0x40+copy_u8Col);
 1d6:	df 92       	push	r13
 1d8:	ef 92       	push	r14
 1da:	ff 92       	push	r15
 1dc:	0f 93       	push	r16
 1de:	1f 93       	push	r17
 1e0:	cf 93       	push	r28
 1e2:	df 93       	push	r29
 1e4:	d8 2e       	mov	r13, r24
 1e6:	e1 2c       	mov	r14, r1
 1e8:	f1 2c       	mov	r15, r1
 1ea:	07 e0       	ldi	r16, 0x07	; 7
 1ec:	10 e0       	ldi	r17, 0x00	; 0
 1ee:	35 c0       	rjmp	.+106    	; 0x25a <H_LCD_void_latchByte+0x84>
 1f0:	4d 2d       	mov	r20, r13
 1f2:	50 e0       	ldi	r21, 0x00	; 0
 1f4:	00 2e       	mov	r0, r16
 1f6:	02 c0       	rjmp	.+4      	; 0x1fc <H_LCD_void_latchByte+0x26>
 1f8:	55 95       	asr	r21
 1fa:	47 95       	ror	r20
 1fc:	0a 94       	dec	r0
 1fe:	e2 f7       	brpl	.-8      	; 0x1f8 <H_LCD_void_latchByte+0x22>
 200:	41 70       	andi	r20, 0x01	; 1
 202:	fe 01       	movw	r30, r28
 204:	e0 5a       	subi	r30, 0xA0	; 160
 206:	ff 4f       	sbci	r31, 0xFF	; 255
 208:	60 81       	ld	r22, Z
 20a:	89 e3       	ldi	r24, 0x39	; 57
 20c:	90 e0       	ldi	r25, 0x00	; 0
 20e:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
 212:	01 50       	subi	r16, 0x01	; 1
 214:	11 09       	sbc	r17, r1
 216:	21 96       	adiw	r28, 0x01	; 1
 218:	02 c0       	rjmp	.+4      	; 0x21e <H_LCD_void_latchByte+0x48>
 21a:	c0 e0       	ldi	r28, 0x00	; 0
 21c:	d0 e0       	ldi	r29, 0x00	; 0
 21e:	c4 30       	cpi	r28, 0x04	; 4
 220:	d1 05       	cpc	r29, r1
 222:	34 f3       	brlt	.-52     	; 0x1f0 <H_LCD_void_latchByte+0x1a>
 224:	41 e0       	ldi	r20, 0x01	; 1
 226:	62 e0       	ldi	r22, 0x02	; 2
 228:	89 e3       	ldi	r24, 0x39	; 57
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
 230:	8f e0       	ldi	r24, 0x0F	; 15
 232:	97 e2       	ldi	r25, 0x27	; 39
 234:	01 97       	sbiw	r24, 0x01	; 1
 236:	f1 f7       	brne	.-4      	; 0x234 <H_LCD_void_latchByte+0x5e>
 238:	00 c0       	rjmp	.+0      	; 0x23a <H_LCD_void_latchByte+0x64>
 23a:	00 00       	nop
 23c:	40 e0       	ldi	r20, 0x00	; 0
 23e:	62 e0       	ldi	r22, 0x02	; 2
 240:	89 e3       	ldi	r24, 0x39	; 57
 242:	90 e0       	ldi	r25, 0x00	; 0
 244:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
 248:	8f e0       	ldi	r24, 0x0F	; 15
 24a:	97 e2       	ldi	r25, 0x27	; 39
 24c:	01 97       	sbiw	r24, 0x01	; 1
 24e:	f1 f7       	brne	.-4      	; 0x24c <H_LCD_void_latchByte+0x76>
 250:	00 c0       	rjmp	.+0      	; 0x252 <H_LCD_void_latchByte+0x7c>
 252:	00 00       	nop
 254:	9f ef       	ldi	r25, 0xFF	; 255
 256:	e9 1a       	sub	r14, r25
 258:	f9 0a       	sbc	r15, r25
 25a:	82 e0       	ldi	r24, 0x02	; 2
 25c:	e8 16       	cp	r14, r24
 25e:	f1 04       	cpc	r15, r1
 260:	e4 f2       	brlt	.-72     	; 0x21a <H_LCD_void_latchByte+0x44>
 262:	df 91       	pop	r29
 264:	cf 91       	pop	r28
 266:	1f 91       	pop	r17
 268:	0f 91       	pop	r16
 26a:	ff 90       	pop	r15
 26c:	ef 90       	pop	r14
 26e:	df 90       	pop	r13
 270:	08 95       	ret

00000272 <H_LCD_void_sendData>:
 272:	cf 93       	push	r28
 274:	c8 2f       	mov	r28, r24
 276:	41 e0       	ldi	r20, 0x01	; 1
 278:	61 e0       	ldi	r22, 0x01	; 1
 27a:	89 e3       	ldi	r24, 0x39	; 57
 27c:	90 e0       	ldi	r25, 0x00	; 0
 27e:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
 282:	8c 2f       	mov	r24, r28
 284:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <H_LCD_void_latchByte>
 288:	8f ec       	ldi	r24, 0xCF	; 207
 28a:	97 e0       	ldi	r25, 0x07	; 7
 28c:	01 97       	sbiw	r24, 0x01	; 1
 28e:	f1 f7       	brne	.-4      	; 0x28c <H_LCD_void_sendData+0x1a>
 290:	00 c0       	rjmp	.+0      	; 0x292 <H_LCD_void_sendData+0x20>
 292:	00 00       	nop
 294:	cf 91       	pop	r28
 296:	08 95       	ret

00000298 <H_LCD_void_sendCommand>:
 298:	cf 93       	push	r28
 29a:	c8 2f       	mov	r28, r24
 29c:	40 e0       	ldi	r20, 0x00	; 0
 29e:	61 e0       	ldi	r22, 0x01	; 1
 2a0:	89 e3       	ldi	r24, 0x39	; 57
 2a2:	90 e0       	ldi	r25, 0x00	; 0
 2a4:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
 2a8:	8c 2f       	mov	r24, r28
 2aa:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <H_LCD_void_latchByte>
 2ae:	8f ec       	ldi	r24, 0xCF	; 207
 2b0:	97 e0       	ldi	r25, 0x07	; 7
 2b2:	01 97       	sbiw	r24, 0x01	; 1
 2b4:	f1 f7       	brne	.-4      	; 0x2b2 <H_LCD_void_sendCommand+0x1a>
 2b6:	00 c0       	rjmp	.+0      	; 0x2b8 <H_LCD_void_sendCommand+0x20>
 2b8:	00 00       	nop
 2ba:	cf 91       	pop	r28
 2bc:	08 95       	ret

000002be <H_LCD_void_Init>:
 2be:	41 e0       	ldi	r20, 0x01	; 1
 2c0:	61 e0       	ldi	r22, 0x01	; 1
 2c2:	89 e3       	ldi	r24, 0x39	; 57
 2c4:	90 e0       	ldi	r25, 0x00	; 0
 2c6:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
 2ca:	41 e0       	ldi	r20, 0x01	; 1
 2cc:	62 e0       	ldi	r22, 0x02	; 2
 2ce:	89 e3       	ldi	r24, 0x39	; 57
 2d0:	90 e0       	ldi	r25, 0x00	; 0
 2d2:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
 2d6:	41 e0       	ldi	r20, 0x01	; 1
 2d8:	63 e0       	ldi	r22, 0x03	; 3
 2da:	89 e3       	ldi	r24, 0x39	; 57
 2dc:	90 e0       	ldi	r25, 0x00	; 0
 2de:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
 2e2:	41 e0       	ldi	r20, 0x01	; 1
 2e4:	64 e0       	ldi	r22, 0x04	; 4
 2e6:	89 e3       	ldi	r24, 0x39	; 57
 2e8:	90 e0       	ldi	r25, 0x00	; 0
 2ea:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
 2ee:	41 e0       	ldi	r20, 0x01	; 1
 2f0:	65 e0       	ldi	r22, 0x05	; 5
 2f2:	89 e3       	ldi	r24, 0x39	; 57
 2f4:	90 e0       	ldi	r25, 0x00	; 0
 2f6:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
 2fa:	41 e0       	ldi	r20, 0x01	; 1
 2fc:	66 e0       	ldi	r22, 0x06	; 6
 2fe:	89 e3       	ldi	r24, 0x39	; 57
 300:	90 e0       	ldi	r25, 0x00	; 0
 302:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
 306:	2f e7       	ldi	r18, 0x7F	; 127
 308:	88 e3       	ldi	r24, 0x38	; 56
 30a:	91 e0       	ldi	r25, 0x01	; 1
 30c:	21 50       	subi	r18, 0x01	; 1
 30e:	80 40       	sbci	r24, 0x00	; 0
 310:	90 40       	sbci	r25, 0x00	; 0
 312:	e1 f7       	brne	.-8      	; 0x30c <H_LCD_void_Init+0x4e>
 314:	00 c0       	rjmp	.+0      	; 0x316 <H_LCD_void_Init+0x58>
 316:	00 00       	nop
 318:	40 e0       	ldi	r20, 0x00	; 0
 31a:	61 e0       	ldi	r22, 0x01	; 1
 31c:	89 e3       	ldi	r24, 0x39	; 57
 31e:	90 e0       	ldi	r25, 0x00	; 0
 320:	0e 94 53 04 	call	0x8a6	; 0x8a6 <DIO_voidSetPinValue>
 324:	82 e0       	ldi	r24, 0x02	; 2
 326:	0e 94 4c 01 	call	0x298	; 0x298 <H_LCD_void_sendCommand>
 32a:	82 e0       	ldi	r24, 0x02	; 2
 32c:	0e 94 4c 01 	call	0x298	; 0x298 <H_LCD_void_sendCommand>
 330:	88 e0       	ldi	r24, 0x08	; 8
 332:	0e 94 4c 01 	call	0x298	; 0x298 <H_LCD_void_sendCommand>
 336:	8f ec       	ldi	r24, 0xCF	; 207
 338:	97 e0       	ldi	r25, 0x07	; 7
 33a:	01 97       	sbiw	r24, 0x01	; 1
 33c:	f1 f7       	brne	.-4      	; 0x33a <H_LCD_void_Init+0x7c>
 33e:	00 c0       	rjmp	.+0      	; 0x340 <H_LCD_void_Init+0x82>
 340:	00 00       	nop
 342:	80 e0       	ldi	r24, 0x00	; 0
 344:	0e 94 4c 01 	call	0x298	; 0x298 <H_LCD_void_sendCommand>
 348:	8c e0       	ldi	r24, 0x0C	; 12
 34a:	0e 94 4c 01 	call	0x298	; 0x298 <H_LCD_void_sendCommand>
 34e:	8f ec       	ldi	r24, 0xCF	; 207
 350:	97 e0       	ldi	r25, 0x07	; 7
 352:	01 97       	sbiw	r24, 0x01	; 1
 354:	f1 f7       	brne	.-4      	; 0x352 <H_LCD_void_Init+0x94>
 356:	00 c0       	rjmp	.+0      	; 0x358 <H_LCD_void_Init+0x9a>
 358:	00 00       	nop
 35a:	80 e0       	ldi	r24, 0x00	; 0
 35c:	0e 94 4c 01 	call	0x298	; 0x298 <H_LCD_void_sendCommand>
 360:	81 e0       	ldi	r24, 0x01	; 1
 362:	0e 94 4c 01 	call	0x298	; 0x298 <H_LCD_void_sendCommand>
 366:	8f e6       	ldi	r24, 0x6F	; 111
 368:	97 e1       	ldi	r25, 0x17	; 23
 36a:	01 97       	sbiw	r24, 0x01	; 1
 36c:	f1 f7       	brne	.-4      	; 0x36a <H_LCD_void_Init+0xac>
 36e:	00 c0       	rjmp	.+0      	; 0x370 <H_LCD_void_Init+0xb2>
 370:	00 00       	nop
 372:	80 e0       	ldi	r24, 0x00	; 0
 374:	0e 94 4c 01 	call	0x298	; 0x298 <H_LCD_void_sendCommand>
 378:	86 e0       	ldi	r24, 0x06	; 6
 37a:	0e 94 4c 01 	call	0x298	; 0x298 <H_LCD_void_sendCommand>
 37e:	08 95       	ret

00000380 <H_LCD_void_sendIntNum>:
 380:	cf 92       	push	r12
 382:	df 92       	push	r13
 384:	ef 92       	push	r14
 386:	ff 92       	push	r15
 388:	0f 93       	push	r16
 38a:	1f 93       	push	r17
 38c:	cf 93       	push	r28
 38e:	df 93       	push	r29
 390:	cd b7       	in	r28, 0x3d	; 61
 392:	de b7       	in	r29, 0x3e	; 62
 394:	64 97       	sbiw	r28, 0x14	; 20
 396:	0f b6       	in	r0, 0x3f	; 63
 398:	f8 94       	cli
 39a:	de bf       	out	0x3e, r29	; 62
 39c:	0f be       	out	0x3f, r0	; 63
 39e:	cd bf       	out	0x3d, r28	; 61
 3a0:	6b 01       	movw	r12, r22
 3a2:	7c 01       	movw	r14, r24
 3a4:	fe 01       	movw	r30, r28
 3a6:	31 96       	adiw	r30, 0x01	; 1
 3a8:	84 e1       	ldi	r24, 0x14	; 20
 3aa:	df 01       	movw	r26, r30
 3ac:	1d 92       	st	X+, r1
 3ae:	8a 95       	dec	r24
 3b0:	e9 f7       	brne	.-6      	; 0x3ac <H_LCD_void_sendIntNum+0x2c>
 3b2:	c1 14       	cp	r12, r1
 3b4:	d1 04       	cpc	r13, r1
 3b6:	e1 04       	cpc	r14, r1
 3b8:	f1 04       	cpc	r15, r1
 3ba:	21 f4       	brne	.+8      	; 0x3c4 <H_LCD_void_sendIntNum+0x44>
 3bc:	80 e3       	ldi	r24, 0x30	; 48
 3be:	0e 94 39 01 	call	0x272	; 0x272 <H_LCD_void_sendData>
 3c2:	3a c0       	rjmp	.+116    	; 0x438 <__EEPROM_REGION_LENGTH__+0x38>
 3c4:	ff 20       	and	r15, r15
 3c6:	5c f4       	brge	.+22     	; 0x3de <H_LCD_void_sendIntNum+0x5e>
 3c8:	8d e2       	ldi	r24, 0x2D	; 45
 3ca:	0e 94 39 01 	call	0x272	; 0x272 <H_LCD_void_sendData>
 3ce:	f0 94       	com	r15
 3d0:	e0 94       	com	r14
 3d2:	d0 94       	com	r13
 3d4:	c0 94       	com	r12
 3d6:	c1 1c       	adc	r12, r1
 3d8:	d1 1c       	adc	r13, r1
 3da:	e1 1c       	adc	r14, r1
 3dc:	f1 1c       	adc	r15, r1
 3de:	00 e0       	ldi	r16, 0x00	; 0
 3e0:	10 e0       	ldi	r17, 0x00	; 0
 3e2:	15 c0       	rjmp	.+42     	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
 3e4:	c7 01       	movw	r24, r14
 3e6:	b6 01       	movw	r22, r12
 3e8:	2a e0       	ldi	r18, 0x0A	; 10
 3ea:	30 e0       	ldi	r19, 0x00	; 0
 3ec:	40 e0       	ldi	r20, 0x00	; 0
 3ee:	50 e0       	ldi	r21, 0x00	; 0
 3f0:	0e 94 d3 06 	call	0xda6	; 0xda6 <__divmodsi4>
 3f4:	e1 e0       	ldi	r30, 0x01	; 1
 3f6:	f0 e0       	ldi	r31, 0x00	; 0
 3f8:	ec 0f       	add	r30, r28
 3fa:	fd 1f       	adc	r31, r29
 3fc:	e0 0f       	add	r30, r16
 3fe:	f1 1f       	adc	r31, r17
 400:	60 83       	st	Z, r22
 402:	c2 2e       	mov	r12, r18
 404:	d3 2e       	mov	r13, r19
 406:	e4 2e       	mov	r14, r20
 408:	f5 2e       	mov	r15, r21
 40a:	0f 5f       	subi	r16, 0xFF	; 255
 40c:	1f 4f       	sbci	r17, 0xFF	; 255
 40e:	1c 14       	cp	r1, r12
 410:	1d 04       	cpc	r1, r13
 412:	1e 04       	cpc	r1, r14
 414:	1f 04       	cpc	r1, r15
 416:	34 f3       	brlt	.-52     	; 0x3e4 <H_LCD_void_sendIntNum+0x64>
 418:	0c c0       	rjmp	.+24     	; 0x432 <__EEPROM_REGION_LENGTH__+0x32>
 41a:	01 50       	subi	r16, 0x01	; 1
 41c:	11 09       	sbc	r17, r1
 41e:	e1 e0       	ldi	r30, 0x01	; 1
 420:	f0 e0       	ldi	r31, 0x00	; 0
 422:	ec 0f       	add	r30, r28
 424:	fd 1f       	adc	r31, r29
 426:	e0 0f       	add	r30, r16
 428:	f1 1f       	adc	r31, r17
 42a:	80 81       	ld	r24, Z
 42c:	80 5d       	subi	r24, 0xD0	; 208
 42e:	0e 94 39 01 	call	0x272	; 0x272 <H_LCD_void_sendData>
 432:	10 16       	cp	r1, r16
 434:	11 06       	cpc	r1, r17
 436:	8c f3       	brlt	.-30     	; 0x41a <__EEPROM_REGION_LENGTH__+0x1a>
 438:	64 96       	adiw	r28, 0x14	; 20
 43a:	0f b6       	in	r0, 0x3f	; 63
 43c:	f8 94       	cli
 43e:	de bf       	out	0x3e, r29	; 62
 440:	0f be       	out	0x3f, r0	; 63
 442:	cd bf       	out	0x3d, r28	; 61
 444:	df 91       	pop	r29
 446:	cf 91       	pop	r28
 448:	1f 91       	pop	r17
 44a:	0f 91       	pop	r16
 44c:	ff 90       	pop	r15
 44e:	ef 90       	pop	r14
 450:	df 90       	pop	r13
 452:	cf 90       	pop	r12
 454:	08 95       	ret

00000456 <H_LCD_void_clear>:
	}
}

void H_LCD_void_clear(void)
{
	H_LCD_void_sendCommand(0x01);
 456:	81 e0       	ldi	r24, 0x01	; 1
 458:	0e 94 4c 01 	call	0x298	; 0x298 <H_LCD_void_sendCommand>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 45c:	8f ec       	ldi	r24, 0xCF	; 207
 45e:	97 e0       	ldi	r25, 0x07	; 7
 460:	01 97       	sbiw	r24, 0x01	; 1
 462:	f1 f7       	brne	.-4      	; 0x460 <H_LCD_void_clear+0xa>
 464:	00 c0       	rjmp	.+0      	; 0x466 <H_LCD_void_clear+0x10>
 466:	00 00       	nop
 468:	08 95       	ret

0000046a <decimal_BCD>:
		//step 8 : check status TWI_MT_DATA_ACK
		I2C_getStatus(&status);
		if (status !=MT_SLA_W_NOT_ACK) return;
		//step 9 : send stop
		I2C_sendStop();
}
 46a:	40 e0       	ldi	r20, 0x00	; 0
 46c:	50 e0       	ldi	r21, 0x00	; 0
 46e:	e0 e0       	ldi	r30, 0x00	; 0
 470:	f0 e0       	ldi	r31, 0x00	; 0
 472:	1b c0       	rjmp	.+54     	; 0x4aa <decimal_BCD+0x40>
 474:	9d ec       	ldi	r25, 0xCD	; 205
 476:	89 9f       	mul	r24, r25
 478:	91 2d       	mov	r25, r1
 47a:	11 24       	eor	r1, r1
 47c:	96 95       	lsr	r25
 47e:	96 95       	lsr	r25
 480:	96 95       	lsr	r25
 482:	69 2f       	mov	r22, r25
 484:	66 0f       	add	r22, r22
 486:	36 2f       	mov	r19, r22
 488:	33 0f       	add	r19, r19
 48a:	33 0f       	add	r19, r19
 48c:	36 0f       	add	r19, r22
 48e:	28 2f       	mov	r18, r24
 490:	23 1b       	sub	r18, r19
 492:	30 e0       	ldi	r19, 0x00	; 0
 494:	04 2e       	mov	r0, r20
 496:	02 c0       	rjmp	.+4      	; 0x49c <decimal_BCD+0x32>
 498:	22 0f       	add	r18, r18
 49a:	33 1f       	adc	r19, r19
 49c:	0a 94       	dec	r0
 49e:	e2 f7       	brpl	.-8      	; 0x498 <decimal_BCD+0x2e>
 4a0:	e2 0f       	add	r30, r18
 4a2:	f3 1f       	adc	r31, r19
 4a4:	4c 5f       	subi	r20, 0xFC	; 252
 4a6:	5f 4f       	sbci	r21, 0xFF	; 255
 4a8:	89 2f       	mov	r24, r25
 4aa:	81 11       	cpse	r24, r1
 4ac:	e3 cf       	rjmp	.-58     	; 0x474 <decimal_BCD+0xa>
 4ae:	8e 2f       	mov	r24, r30
 4b0:	08 95       	ret

000004b2 <BCD_to_Decimal>:
 4b2:	98 2f       	mov	r25, r24
 4b4:	92 95       	swap	r25
 4b6:	9f 70       	andi	r25, 0x0F	; 15
 4b8:	8f 70       	andi	r24, 0x0F	; 15
 4ba:	99 0f       	add	r25, r25
 4bc:	29 2f       	mov	r18, r25
 4be:	22 0f       	add	r18, r18
 4c0:	22 0f       	add	r18, r18
 4c2:	92 0f       	add	r25, r18
 4c4:	89 0f       	add	r24, r25
 4c6:	08 95       	ret

000004c8 <RTC_Init>:
 4c8:	60 e0       	ldi	r22, 0x00	; 0
 4ca:	80 e0       	ldi	r24, 0x00	; 0
 4cc:	0e 94 0c 05 	call	0xa18	; 0xa18 <I2C_init>
 4d0:	08 95       	ret

000004d2 <RTC_getTime>:
 4d2:	ff 92       	push	r15
 4d4:	0f 93       	push	r16
 4d6:	1f 93       	push	r17
 4d8:	cf 93       	push	r28
 4da:	df 93       	push	r29
 4dc:	00 d0       	rcall	.+0      	; 0x4de <RTC_getTime+0xc>
 4de:	cd b7       	in	r28, 0x3d	; 61
 4e0:	de b7       	in	r29, 0x3e	; 62
 4e2:	0e 94 46 05 	call	0xa8c	; 0xa8c <I2C_sendStart>
 4e6:	ce 01       	movw	r24, r28
 4e8:	02 96       	adiw	r24, 0x02	; 2
 4ea:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
 4ee:	8a 81       	ldd	r24, Y+2	; 0x02
 4f0:	88 30       	cpi	r24, 0x08	; 8
 4f2:	09 f0       	breq	.+2      	; 0x4f6 <RTC_getTime+0x24>
 4f4:	46 c0       	rjmp	.+140    	; 0x582 <RTC_getTime+0xb0>
 4f6:	80 ed       	ldi	r24, 0xD0	; 208
 4f8:	0e 94 3f 05 	call	0xa7e	; 0xa7e <I2C_sendByte>
 4fc:	ce 01       	movw	r24, r28
 4fe:	02 96       	adiw	r24, 0x02	; 2
 500:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
 504:	8a 81       	ldd	r24, Y+2	; 0x02
 506:	88 31       	cpi	r24, 0x18	; 24
 508:	e1 f5       	brne	.+120    	; 0x582 <RTC_getTime+0xb0>
 50a:	80 e0       	ldi	r24, 0x00	; 0
 50c:	0e 94 3f 05 	call	0xa7e	; 0xa7e <I2C_sendByte>
 510:	ce 01       	movw	r24, r28
 512:	02 96       	adiw	r24, 0x02	; 2
 514:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
 518:	8a 81       	ldd	r24, Y+2	; 0x02
 51a:	88 31       	cpi	r24, 0x18	; 24
 51c:	91 f5       	brne	.+100    	; 0x582 <RTC_getTime+0xb0>
 51e:	0e 94 46 05 	call	0xa8c	; 0xa8c <I2C_sendStart>
 522:	ce 01       	movw	r24, r28
 524:	02 96       	adiw	r24, 0x02	; 2
 526:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
 52a:	8a 81       	ldd	r24, Y+2	; 0x02
 52c:	80 34       	cpi	r24, 0x40	; 64
 52e:	49 f5       	brne	.+82     	; 0x582 <RTC_getTime+0xb0>
 530:	81 ed       	ldi	r24, 0xD1	; 209
 532:	0e 94 3f 05 	call	0xa7e	; 0xa7e <I2C_sendByte>
 536:	ce 01       	movw	r24, r28
 538:	02 96       	adiw	r24, 0x02	; 2
 53a:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
 53e:	8a 81       	ldd	r24, Y+2	; 0x02
 540:	88 31       	cpi	r24, 0x18	; 24
 542:	f9 f4       	brne	.+62     	; 0x582 <RTC_getTime+0xb0>
 544:	ce 01       	movw	r24, r28
 546:	01 96       	adiw	r24, 0x01	; 1
 548:	0e 94 52 05 	call	0xaa4	; 0xaa4 <I2C_recieveByte_ACK>
 54c:	89 81       	ldd	r24, Y+1	; 0x01
 54e:	0e 94 59 02 	call	0x4b2	; 0x4b2 <BCD_to_Decimal>
 552:	f8 2e       	mov	r15, r24
 554:	ce 01       	movw	r24, r28
 556:	01 96       	adiw	r24, 0x01	; 1
 558:	0e 94 52 05 	call	0xaa4	; 0xaa4 <I2C_recieveByte_ACK>
 55c:	89 81       	ldd	r24, Y+1	; 0x01
 55e:	0e 94 59 02 	call	0x4b2	; 0x4b2 <BCD_to_Decimal>
 562:	08 2f       	mov	r16, r24
 564:	ce 01       	movw	r24, r28
 566:	01 96       	adiw	r24, 0x01	; 1
 568:	0e 94 5b 05 	call	0xab6	; 0xab6 <I2C_RECIEVENoACK>
 56c:	89 81       	ldd	r24, Y+1	; 0x01
 56e:	0e 94 59 02 	call	0x4b2	; 0x4b2 <BCD_to_Decimal>
 572:	18 2f       	mov	r17, r24
 574:	0e 94 4c 05 	call	0xa98	; 0xa98 <I2C_sendStop>
 578:	6f 2d       	mov	r22, r15
 57a:	70 2f       	mov	r23, r16
 57c:	81 2f       	mov	r24, r17
 57e:	90 e0       	ldi	r25, 0x00	; 0
 580:	00 c0       	rjmp	.+0      	; 0x582 <RTC_getTime+0xb0>
 582:	0f 90       	pop	r0
 584:	0f 90       	pop	r0
 586:	df 91       	pop	r29
 588:	cf 91       	pop	r28
 58a:	1f 91       	pop	r17
 58c:	0f 91       	pop	r16
 58e:	ff 90       	pop	r15
 590:	08 95       	ret

00000592 <RTC_settime>:
 592:	0f 93       	push	r16
 594:	1f 93       	push	r17
 596:	cf 93       	push	r28
 598:	df 93       	push	r29
 59a:	1f 92       	push	r1
 59c:	cd b7       	in	r28, 0x3d	; 61
 59e:	de b7       	in	r29, 0x3e	; 62
 5a0:	8c 01       	movw	r16, r24
 5a2:	0e 94 46 05 	call	0xa8c	; 0xa8c <I2C_sendStart>
 5a6:	ce 01       	movw	r24, r28
 5a8:	01 96       	adiw	r24, 0x01	; 1
 5aa:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
 5ae:	89 81       	ldd	r24, Y+1	; 0x01
 5b0:	88 30       	cpi	r24, 0x08	; 8
 5b2:	09 f0       	breq	.+2      	; 0x5b6 <RTC_settime+0x24>
 5b4:	4e c0       	rjmp	.+156    	; 0x652 <RTC_settime+0xc0>
 5b6:	80 ed       	ldi	r24, 0xD0	; 208
 5b8:	0e 94 3f 05 	call	0xa7e	; 0xa7e <I2C_sendByte>
 5bc:	ce 01       	movw	r24, r28
 5be:	01 96       	adiw	r24, 0x01	; 1
 5c0:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
 5c4:	89 81       	ldd	r24, Y+1	; 0x01
 5c6:	88 31       	cpi	r24, 0x18	; 24
 5c8:	09 f0       	breq	.+2      	; 0x5cc <RTC_settime+0x3a>
 5ca:	43 c0       	rjmp	.+134    	; 0x652 <RTC_settime+0xc0>
 5cc:	80 e0       	ldi	r24, 0x00	; 0
 5ce:	0e 94 3f 05 	call	0xa7e	; 0xa7e <I2C_sendByte>
 5d2:	ce 01       	movw	r24, r28
 5d4:	01 96       	adiw	r24, 0x01	; 1
 5d6:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
 5da:	89 81       	ldd	r24, Y+1	; 0x01
 5dc:	88 32       	cpi	r24, 0x28	; 40
 5de:	c9 f5       	brne	.+114    	; 0x652 <RTC_settime+0xc0>
 5e0:	f8 01       	movw	r30, r16
 5e2:	80 81       	ld	r24, Z
 5e4:	0e 94 35 02 	call	0x46a	; 0x46a <decimal_BCD>
 5e8:	0e 94 3f 05 	call	0xa7e	; 0xa7e <I2C_sendByte>
 5ec:	ce 01       	movw	r24, r28
 5ee:	01 96       	adiw	r24, 0x01	; 1
 5f0:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
 5f4:	89 81       	ldd	r24, Y+1	; 0x01
 5f6:	88 32       	cpi	r24, 0x28	; 40
 5f8:	61 f5       	brne	.+88     	; 0x652 <RTC_settime+0xc0>
 5fa:	f8 01       	movw	r30, r16
 5fc:	81 81       	ldd	r24, Z+1	; 0x01
 5fe:	0e 94 35 02 	call	0x46a	; 0x46a <decimal_BCD>
 602:	0e 94 3f 05 	call	0xa7e	; 0xa7e <I2C_sendByte>
 606:	ce 01       	movw	r24, r28
 608:	01 96       	adiw	r24, 0x01	; 1
 60a:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
 60e:	89 81       	ldd	r24, Y+1	; 0x01
 610:	88 32       	cpi	r24, 0x28	; 40
 612:	f9 f4       	brne	.+62     	; 0x652 <RTC_settime+0xc0>
 614:	f8 01       	movw	r30, r16
 616:	82 81       	ldd	r24, Z+2	; 0x02
 618:	0e 94 35 02 	call	0x46a	; 0x46a <decimal_BCD>
 61c:	f8 01       	movw	r30, r16
 61e:	23 81       	ldd	r18, Z+3	; 0x03
 620:	22 23       	and	r18, r18
 622:	61 f0       	breq	.+24     	; 0x63c <RTC_settime+0xaa>
 624:	21 30       	cpi	r18, 0x01	; 1
 626:	39 f4       	brne	.+14     	; 0x636 <RTC_settime+0xa4>
 628:	80 64       	ori	r24, 0x40	; 64
 62a:	f0 e2       	ldi	r31, 0x20	; 32
 62c:	2f 9f       	mul	r18, r31
 62e:	90 01       	movw	r18, r0
 630:	11 24       	eor	r1, r1
 632:	82 2b       	or	r24, r18
 634:	03 c0       	rjmp	.+6      	; 0x63c <RTC_settime+0xaa>
 636:	21 11       	cpse	r18, r1
 638:	01 c0       	rjmp	.+2      	; 0x63c <RTC_settime+0xaa>
 63a:	8f 71       	andi	r24, 0x1F	; 31
 63c:	0e 94 3f 05 	call	0xa7e	; 0xa7e <I2C_sendByte>
 640:	ce 01       	movw	r24, r28
 642:	01 96       	adiw	r24, 0x01	; 1
 644:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
 648:	89 81       	ldd	r24, Y+1	; 0x01
 64a:	80 32       	cpi	r24, 0x20	; 32
 64c:	11 f4       	brne	.+4      	; 0x652 <RTC_settime+0xc0>
 64e:	0e 94 4c 05 	call	0xa98	; 0xa98 <I2C_sendStop>
 652:	0f 90       	pop	r0
 654:	df 91       	pop	r29
 656:	cf 91       	pop	r28
 658:	1f 91       	pop	r17
 65a:	0f 91       	pop	r16
 65c:	08 95       	ret

0000065e <RTC_getdate>:
date_t RTC_getdate(void)
{
 65e:	ef 92       	push	r14
 660:	ff 92       	push	r15
 662:	0f 93       	push	r16
 664:	1f 93       	push	r17
 666:	cf 93       	push	r28
 668:	df 93       	push	r29
 66a:	00 d0       	rcall	.+0      	; 0x66c <RTC_getdate+0xe>
 66c:	cd b7       	in	r28, 0x3d	; 61
 66e:	de b7       	in	r29, 0x3e	; 62
	u8 data,status;
	date_t d;
	I2C_sendStart();
 670:	0e 94 46 05 	call	0xa8c	; 0xa8c <I2C_sendStart>
	I2C_getStatus(&status);
 674:	ce 01       	movw	r24, r28
 676:	02 96       	adiw	r24, 0x02	; 2
 678:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
	if (status !=TWI_MT_START) return;
 67c:	8a 81       	ldd	r24, Y+2	; 0x02
 67e:	88 30       	cpi	r24, 0x08	; 8
 680:	09 f0       	breq	.+2      	; 0x684 <RTC_getdate+0x26>
 682:	4f c0       	rjmp	.+158    	; 0x722 <RTC_getdate+0xc4>
	I2C_sendByte(RTC_ADDRESS_WRITE);
 684:	80 ed       	ldi	r24, 0xD0	; 208
 686:	0e 94 3f 05 	call	0xa7e	; 0xa7e <I2C_sendByte>
	I2C_getStatus(&status);
 68a:	ce 01       	movw	r24, r28
 68c:	02 96       	adiw	r24, 0x02	; 2
 68e:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
	if (status !=TWI_MT_SLA_W_ACK) return;
 692:	8a 81       	ldd	r24, Y+2	; 0x02
 694:	88 31       	cpi	r24, 0x18	; 24
 696:	09 f0       	breq	.+2      	; 0x69a <RTC_getdate+0x3c>
 698:	44 c0       	rjmp	.+136    	; 0x722 <RTC_getdate+0xc4>
	I2C_sendByte(DAY_REG);
 69a:	83 e0       	ldi	r24, 0x03	; 3
 69c:	0e 94 3f 05 	call	0xa7e	; 0xa7e <I2C_sendByte>
	I2C_getStatus(&status);
 6a0:	ce 01       	movw	r24, r28
 6a2:	02 96       	adiw	r24, 0x02	; 2
 6a4:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
	if (status !=TWI_MT_SLA_W_ACK) return;
 6a8:	8a 81       	ldd	r24, Y+2	; 0x02
 6aa:	88 31       	cpi	r24, 0x18	; 24
 6ac:	d1 f5       	brne	.+116    	; 0x722 <RTC_getdate+0xc4>
	I2C_sendStart();
 6ae:	0e 94 46 05 	call	0xa8c	; 0xa8c <I2C_sendStart>
	I2C_getStatus(&status);
 6b2:	ce 01       	movw	r24, r28
 6b4:	02 96       	adiw	r24, 0x02	; 2
 6b6:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
	if (status !=TWI_MR_SLA_R_ACK) return;
 6ba:	8a 81       	ldd	r24, Y+2	; 0x02
 6bc:	80 34       	cpi	r24, 0x40	; 64
 6be:	89 f5       	brne	.+98     	; 0x722 <RTC_getdate+0xc4>
	I2C_sendByte(RTC_ADDRESS_READ);
 6c0:	81 ed       	ldi	r24, 0xD1	; 209
 6c2:	0e 94 3f 05 	call	0xa7e	; 0xa7e <I2C_sendByte>
	I2C_getStatus(&status);
 6c6:	ce 01       	movw	r24, r28
 6c8:	02 96       	adiw	r24, 0x02	; 2
 6ca:	0e 94 64 05 	call	0xac8	; 0xac8 <I2C_getStatus>
	if (status !=TWI_MT_SLA_W_ACK) return;
 6ce:	8a 81       	ldd	r24, Y+2	; 0x02
 6d0:	88 31       	cpi	r24, 0x18	; 24
 6d2:	39 f5       	brne	.+78     	; 0x722 <RTC_getdate+0xc4>
	I2C_recieveByte_ACK(&data);
 6d4:	ce 01       	movw	r24, r28
 6d6:	01 96       	adiw	r24, 0x01	; 1
 6d8:	0e 94 52 05 	call	0xaa4	; 0xaa4 <I2C_recieveByte_ACK>
	d.day=BCD_to_Decimal(data);
 6dc:	89 81       	ldd	r24, Y+1	; 0x01
 6de:	0e 94 59 02 	call	0x4b2	; 0x4b2 <BCD_to_Decimal>
 6e2:	e8 2e       	mov	r14, r24
	I2C_recieveByte_ACK(&data);
 6e4:	ce 01       	movw	r24, r28
 6e6:	01 96       	adiw	r24, 0x01	; 1
 6e8:	0e 94 52 05 	call	0xaa4	; 0xaa4 <I2C_recieveByte_ACK>
	d.date=BCD_to_Decimal(data);
 6ec:	89 81       	ldd	r24, Y+1	; 0x01
 6ee:	0e 94 59 02 	call	0x4b2	; 0x4b2 <BCD_to_Decimal>
 6f2:	f8 2e       	mov	r15, r24
	I2C_recieveByte_ACK(&data);
 6f4:	ce 01       	movw	r24, r28
 6f6:	01 96       	adiw	r24, 0x01	; 1
 6f8:	0e 94 52 05 	call	0xaa4	; 0xaa4 <I2C_recieveByte_ACK>
	d.month=BCD_to_Decimal(data);
 6fc:	89 81       	ldd	r24, Y+1	; 0x01
 6fe:	0e 94 59 02 	call	0x4b2	; 0x4b2 <BCD_to_Decimal>
 702:	08 2f       	mov	r16, r24
	I2C_RECIEVENoACK(&data);
 704:	ce 01       	movw	r24, r28
 706:	01 96       	adiw	r24, 0x01	; 1
 708:	0e 94 5b 05 	call	0xab6	; 0xab6 <I2C_RECIEVENoACK>
	d.year=BCD_to_Decimal(data);
 70c:	89 81       	ldd	r24, Y+1	; 0x01
 70e:	0e 94 59 02 	call	0x4b2	; 0x4b2 <BCD_to_Decimal>
 712:	18 2f       	mov	r17, r24
	I2C_sendStop();
 714:	0e 94 4c 05 	call	0xa98	; 0xa98 <I2C_sendStop>
	return d;
 718:	6e 2d       	mov	r22, r14
 71a:	7f 2d       	mov	r23, r15
 71c:	80 2f       	mov	r24, r16
 71e:	91 2f       	mov	r25, r17
 720:	00 c0       	rjmp	.+0      	; 0x722 <RTC_getdate+0xc4>
 722:	0f 90       	pop	r0
 724:	0f 90       	pop	r0
 726:	df 91       	pop	r29
 728:	cf 91       	pop	r28
 72a:	1f 91       	pop	r17
 72c:	0f 91       	pop	r16
 72e:	ff 90       	pop	r15
 730:	ef 90       	pop	r14
 732:	08 95       	ret

00000734 <main>:
{

}

int main(void)
{
 734:	cf 93       	push	r28
 736:	df 93       	push	r29
 738:	00 d0       	rcall	.+0      	; 0x73a <main+0x6>
 73a:	00 d0       	rcall	.+0      	; 0x73c <main+0x8>
 73c:	cd b7       	in	r28, 0x3d	; 61
 73e:	de b7       	in	r29, 0x3e	; 62
	H_LCD_void_Init();
 740:	0e 94 5f 01 	call	0x2be	; 0x2be <H_LCD_void_Init>
	sevseg_init();
 744:	0e 94 59 00 	call	0xb2	; 0xb2 <sevseg_init>
	keypad_init();
 748:	0e 94 a2 00 	call	0x144	; 0x144 <keypad_init>
	ADC_Init();
 74c:	0e 94 da 03 	call	0x7b4	; 0x7b4 <ADC_Init>
	 // SPI_init(&init);
	 //I2C_init(I2C_prescaler_4,SCL_100);
	// EEPROM_Init();
	//coolingsystem_init();
	
	RTC_Init();
 750:	0e 94 64 02 	call	0x4c8	; 0x4c8 <RTC_Init>
    DIO_voidSetPinDirection(ptrC,0,1);
 754:	41 e0       	ldi	r20, 0x01	; 1
 756:	60 e0       	ldi	r22, 0x00	; 0
 758:	83 e3       	ldi	r24, 0x33	; 51
 75a:	90 e0       	ldi	r25, 0x00	; 0
 75c:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
  DIO_voidSetPinDirection(ptrC,1,1);
 760:	41 e0       	ldi	r20, 0x01	; 1
 762:	61 e0       	ldi	r22, 0x01	; 1
 764:	83 e3       	ldi	r24, 0x33	; 51
 766:	90 e0       	ldi	r25, 0x00	; 0
 768:	0e 94 15 04 	call	0x82a	; 0x82a <DIO_voidSetPinDirection>
	//Timer0_EnableInt(Timer0_Compare_Match);
	//Timer1_ICU_InterruptEnable();
	//Timer1_OVF_InterruptEnable();
	//sei();

	time_t t={30,45,9,PM};
 76c:	8e e1       	ldi	r24, 0x1E	; 30
 76e:	89 83       	std	Y+1, r24	; 0x01
 770:	8d e2       	ldi	r24, 0x2D	; 45
 772:	8a 83       	std	Y+2, r24	; 0x02
 774:	89 e0       	ldi	r24, 0x09	; 9
 776:	8b 83       	std	Y+3, r24	; 0x03
 778:	81 e0       	ldi	r24, 0x01	; 1
 77a:	8c 83       	std	Y+4, r24	; 0x04
	date_t d2,d={3,1,8,99};
	RTC_settime(&t);
 77c:	ce 01       	movw	r24, r28
 77e:	01 96       	adiw	r24, 0x01	; 1
 780:	0e 94 c9 02 	call	0x592	; 0x592 <RTC_settime>
	time_t t2;
	t2=RTC_getTime();
 784:	0e 94 69 02 	call	0x4d2	; 0x4d2 <RTC_getTime>
 788:	17 2f       	mov	r17, r23
	H_LCD_void_clear();
 78a:	0e 94 2b 02 	call	0x456	; 0x456 <H_LCD_void_clear>
	H_LCD_void_sendIntNum((u32)t2.Minutes);
 78e:	61 2f       	mov	r22, r17
 790:	70 e0       	ldi	r23, 0x00	; 0
 792:	80 e0       	ldi	r24, 0x00	; 0
 794:	90 e0       	ldi	r25, 0x00	; 0
 796:	0e 94 c0 01 	call	0x380	; 0x380 <H_LCD_void_sendIntNum>
	d2=RTC_getdate();
 79a:	0e 94 2f 03 	call	0x65e	; 0x65e <RTC_getdate>
 79e:	19 2f       	mov	r17, r25
	H_LCD_void_sendData('D');
 7a0:	84 e4       	ldi	r24, 0x44	; 68
 7a2:	0e 94 39 01 	call	0x272	; 0x272 <H_LCD_void_sendData>
	H_LCD_void_sendIntNum((u32)d2.year);
 7a6:	61 2f       	mov	r22, r17
 7a8:	70 e0       	ldi	r23, 0x00	; 0
 7aa:	80 e0       	ldi	r24, 0x00	; 0
 7ac:	90 e0       	ldi	r25, 0x00	; 0
 7ae:	0e 94 c0 01 	call	0x380	; 0x380 <H_LCD_void_sendIntNum>
 7b2:	ff cf       	rjmp	.-2      	; 0x7b2 <main+0x7e>

000007b4 <ADC_Init>:
	//set call back pointer
	if (p!= 0) EXT_INT_ptr=p;
	//enable interrupt
	SET_BIT(ADCSRA,ADIE);
	//start conversion
	SET_BIT(ADCSRA,ADSC);
 7b4:	86 b1       	in	r24, 0x06	; 6
 7b6:	88 7f       	andi	r24, 0xF8	; 248
 7b8:	86 b9       	out	0x06, r24	; 6
 7ba:	86 b1       	in	r24, 0x06	; 6
 7bc:	83 60       	ori	r24, 0x03	; 3
 7be:	86 b9       	out	0x06, r24	; 6
 7c0:	87 b1       	in	r24, 0x07	; 7
 7c2:	8f 73       	andi	r24, 0x3F	; 63
 7c4:	87 b9       	out	0x07, r24	; 7
 7c6:	87 b1       	in	r24, 0x07	; 7
 7c8:	87 b9       	out	0x07, r24	; 7
 7ca:	87 b1       	in	r24, 0x07	; 7
 7cc:	8f 7d       	andi	r24, 0xDF	; 223
 7ce:	87 b9       	out	0x07, r24	; 7
 7d0:	86 b1       	in	r24, 0x06	; 6
 7d2:	80 68       	ori	r24, 0x80	; 128
 7d4:	86 b9       	out	0x06, r24	; 6
 7d6:	08 95       	ret

000007d8 <__vector_16>:
	
}

ISR(ADC_vect)
{
 7d8:	1f 92       	push	r1
 7da:	0f 92       	push	r0
 7dc:	0f b6       	in	r0, 0x3f	; 63
 7de:	0f 92       	push	r0
 7e0:	11 24       	eor	r1, r1
 7e2:	2f 93       	push	r18
 7e4:	3f 93       	push	r19
 7e6:	4f 93       	push	r20
 7e8:	5f 93       	push	r21
 7ea:	6f 93       	push	r22
 7ec:	7f 93       	push	r23
 7ee:	8f 93       	push	r24
 7f0:	9f 93       	push	r25
 7f2:	af 93       	push	r26
 7f4:	bf 93       	push	r27
 7f6:	ef 93       	push	r30
 7f8:	ff 93       	push	r31

	if (EXT_INT_ptr!=0)
 7fa:	e0 91 64 00 	lds	r30, 0x0064	; 0x800064 <__data_end>
 7fe:	f0 91 65 00 	lds	r31, 0x0065	; 0x800065 <__data_end+0x1>
 802:	30 97       	sbiw	r30, 0x00	; 0
 804:	09 f0       	breq	.+2      	; 0x808 <__DATA_REGION_LENGTH__+0x8>
	{
		EXT_INT_ptr();
 806:	09 95       	icall
	}
}
 808:	ff 91       	pop	r31
 80a:	ef 91       	pop	r30
 80c:	bf 91       	pop	r27
 80e:	af 91       	pop	r26
 810:	9f 91       	pop	r25
 812:	8f 91       	pop	r24
 814:	7f 91       	pop	r23
 816:	6f 91       	pop	r22
 818:	5f 91       	pop	r21
 81a:	4f 91       	pop	r20
 81c:	3f 91       	pop	r19
 81e:	2f 91       	pop	r18
 820:	0f 90       	pop	r0
 822:	0f be       	out	0x3f, r0	; 63
 824:	0f 90       	pop	r0
 826:	1f 90       	pop	r1
 828:	18 95       	reti

0000082a <DIO_voidSetPinDirection>:

#include "C:\Users\USER\Desktop\nti repo\NTI\NTI_AVR\NTI_AVR\MCAL\DIO\Dio.h"
#include "C:\Users\USER\Desktop\nti repo\NTI\NTI_AVR\NTI_AVR\MCAL\DIO\Dio_Private.h"
#include "C:\Users\USER\Desktop\nti repo\NTI\NTI_AVR\NTI_AVR\stdtypes.h"
void DIO_voidSetPinDirection(ports_t *ptr,unsigned char p,Direction dir )
{
 82a:	0f 93       	push	r16
 82c:	1f 93       	push	r17
	switch(p)
 82e:	06 2f       	mov	r16, r22
 830:	10 e0       	ldi	r17, 0x00	; 0
 832:	08 30       	cpi	r16, 0x08	; 8
 834:	11 05       	cpc	r17, r1
 836:	a0 f5       	brcc	.+104    	; 0x8a0 <__stack+0x41>
 838:	f8 01       	movw	r30, r16
 83a:	e6 5d       	subi	r30, 0xD6	; 214
 83c:	ff 4f       	sbci	r31, 0xFF	; 255
 83e:	0c 94 f2 06 	jmp	0xde4	; 0xde4 <__tablejump2__>
	{
		case 0: ptr->DDR.PIN0=dir; break;
 842:	fc 01       	movw	r30, r24
 844:	21 81       	ldd	r18, Z+1	; 0x01
 846:	40 fb       	bst	r20, 0
 848:	20 f9       	bld	r18, 0
 84a:	21 83       	std	Z+1, r18	; 0x01
 84c:	29 c0       	rjmp	.+82     	; 0x8a0 <__stack+0x41>
		case 1: ptr->DDR.PIN1=dir; break;
 84e:	fc 01       	movw	r30, r24
 850:	21 81       	ldd	r18, Z+1	; 0x01
 852:	40 fb       	bst	r20, 0
 854:	21 f9       	bld	r18, 1
 856:	21 83       	std	Z+1, r18	; 0x01
 858:	23 c0       	rjmp	.+70     	; 0x8a0 <__stack+0x41>
		case 2: ptr->DDR.PIN2=dir; break;
 85a:	fc 01       	movw	r30, r24
 85c:	21 81       	ldd	r18, Z+1	; 0x01
 85e:	40 fb       	bst	r20, 0
 860:	22 f9       	bld	r18, 2
 862:	21 83       	std	Z+1, r18	; 0x01
 864:	1d c0       	rjmp	.+58     	; 0x8a0 <__stack+0x41>
		case 3: ptr->DDR.PIN3=dir; break;
 866:	fc 01       	movw	r30, r24
 868:	21 81       	ldd	r18, Z+1	; 0x01
 86a:	40 fb       	bst	r20, 0
 86c:	23 f9       	bld	r18, 3
 86e:	21 83       	std	Z+1, r18	; 0x01
 870:	17 c0       	rjmp	.+46     	; 0x8a0 <__stack+0x41>
		case 4: ptr->DDR.PIN4=dir; break;
 872:	fc 01       	movw	r30, r24
 874:	21 81       	ldd	r18, Z+1	; 0x01
 876:	40 fb       	bst	r20, 0
 878:	24 f9       	bld	r18, 4
 87a:	21 83       	std	Z+1, r18	; 0x01
 87c:	11 c0       	rjmp	.+34     	; 0x8a0 <__stack+0x41>
		case 5: ptr->DDR.PIN5=dir; break;
 87e:	fc 01       	movw	r30, r24
 880:	21 81       	ldd	r18, Z+1	; 0x01
 882:	40 fb       	bst	r20, 0
 884:	25 f9       	bld	r18, 5
 886:	21 83       	std	Z+1, r18	; 0x01
 888:	0b c0       	rjmp	.+22     	; 0x8a0 <__stack+0x41>
		case 6: ptr->DDR.PIN6=dir; break;
 88a:	fc 01       	movw	r30, r24
 88c:	21 81       	ldd	r18, Z+1	; 0x01
 88e:	40 fb       	bst	r20, 0
 890:	26 f9       	bld	r18, 6
 892:	21 83       	std	Z+1, r18	; 0x01
 894:	05 c0       	rjmp	.+10     	; 0x8a0 <__stack+0x41>
		case 7: ptr->DDR.PIN7=dir; break;
 896:	fc 01       	movw	r30, r24
 898:	21 81       	ldd	r18, Z+1	; 0x01
 89a:	40 fb       	bst	r20, 0
 89c:	27 f9       	bld	r18, 7
 89e:	21 83       	std	Z+1, r18	; 0x01
	}
}
 8a0:	1f 91       	pop	r17
 8a2:	0f 91       	pop	r16
 8a4:	08 95       	ret

000008a6 <DIO_voidSetPinValue>:

void DIO_voidSetPinValue(ports_t *ptr,unsigned char p,Value val)
{
 8a6:	0f 93       	push	r16
 8a8:	1f 93       	push	r17
	switch(p)
 8aa:	06 2f       	mov	r16, r22
 8ac:	10 e0       	ldi	r17, 0x00	; 0
 8ae:	08 30       	cpi	r16, 0x08	; 8
 8b0:	11 05       	cpc	r17, r1
 8b2:	a0 f5       	brcc	.+104    	; 0x91c <DIO_voidSetPinValue+0x76>
 8b4:	f8 01       	movw	r30, r16
 8b6:	ee 5c       	subi	r30, 0xCE	; 206
 8b8:	ff 4f       	sbci	r31, 0xFF	; 255
 8ba:	0c 94 f2 06 	jmp	0xde4	; 0xde4 <__tablejump2__>
	{
		case 0: ptr->port.PIN0=val; break;
 8be:	fc 01       	movw	r30, r24
 8c0:	22 81       	ldd	r18, Z+2	; 0x02
 8c2:	40 fb       	bst	r20, 0
 8c4:	20 f9       	bld	r18, 0
 8c6:	22 83       	std	Z+2, r18	; 0x02
 8c8:	29 c0       	rjmp	.+82     	; 0x91c <DIO_voidSetPinValue+0x76>
		case 1: ptr->port.PIN1=val; break;
 8ca:	fc 01       	movw	r30, r24
 8cc:	22 81       	ldd	r18, Z+2	; 0x02
 8ce:	40 fb       	bst	r20, 0
 8d0:	21 f9       	bld	r18, 1
 8d2:	22 83       	std	Z+2, r18	; 0x02
 8d4:	23 c0       	rjmp	.+70     	; 0x91c <DIO_voidSetPinValue+0x76>
		case 2: ptr->port.PIN2=val; break;
 8d6:	fc 01       	movw	r30, r24
 8d8:	22 81       	ldd	r18, Z+2	; 0x02
 8da:	40 fb       	bst	r20, 0
 8dc:	22 f9       	bld	r18, 2
 8de:	22 83       	std	Z+2, r18	; 0x02
 8e0:	1d c0       	rjmp	.+58     	; 0x91c <DIO_voidSetPinValue+0x76>
		case 3: ptr->port.PIN3=val; break;
 8e2:	fc 01       	movw	r30, r24
 8e4:	22 81       	ldd	r18, Z+2	; 0x02
 8e6:	40 fb       	bst	r20, 0
 8e8:	23 f9       	bld	r18, 3
 8ea:	22 83       	std	Z+2, r18	; 0x02
 8ec:	17 c0       	rjmp	.+46     	; 0x91c <DIO_voidSetPinValue+0x76>
		case 4: ptr->port.PIN4=val; break;
 8ee:	fc 01       	movw	r30, r24
 8f0:	22 81       	ldd	r18, Z+2	; 0x02
 8f2:	40 fb       	bst	r20, 0
 8f4:	24 f9       	bld	r18, 4
 8f6:	22 83       	std	Z+2, r18	; 0x02
 8f8:	11 c0       	rjmp	.+34     	; 0x91c <DIO_voidSetPinValue+0x76>
		case 5: ptr->port.PIN5=val; break;
 8fa:	fc 01       	movw	r30, r24
 8fc:	22 81       	ldd	r18, Z+2	; 0x02
 8fe:	40 fb       	bst	r20, 0
 900:	25 f9       	bld	r18, 5
 902:	22 83       	std	Z+2, r18	; 0x02
 904:	0b c0       	rjmp	.+22     	; 0x91c <DIO_voidSetPinValue+0x76>
		case 6: ptr->port.PIN6=val; break;
 906:	fc 01       	movw	r30, r24
 908:	22 81       	ldd	r18, Z+2	; 0x02
 90a:	40 fb       	bst	r20, 0
 90c:	26 f9       	bld	r18, 6
 90e:	22 83       	std	Z+2, r18	; 0x02
 910:	05 c0       	rjmp	.+10     	; 0x91c <DIO_voidSetPinValue+0x76>
		case 7: ptr->port.PIN7=val; break;
 912:	fc 01       	movw	r30, r24
 914:	22 81       	ldd	r18, Z+2	; 0x02
 916:	40 fb       	bst	r20, 0
 918:	27 f9       	bld	r18, 7
 91a:	22 83       	std	Z+2, r18	; 0x02
	}
}
 91c:	1f 91       	pop	r17
 91e:	0f 91       	pop	r16
 920:	08 95       	ret

00000922 <__vector_1>:
	}
	
}

ISR(INT0_vect)
{
 922:	1f 92       	push	r1
 924:	0f 92       	push	r0
 926:	0f b6       	in	r0, 0x3f	; 63
 928:	0f 92       	push	r0
 92a:	11 24       	eor	r1, r1
 92c:	2f 93       	push	r18
 92e:	3f 93       	push	r19
 930:	4f 93       	push	r20
 932:	5f 93       	push	r21
 934:	6f 93       	push	r22
 936:	7f 93       	push	r23
 938:	8f 93       	push	r24
 93a:	9f 93       	push	r25
 93c:	af 93       	push	r26
 93e:	bf 93       	push	r27
 940:	ef 93       	push	r30
 942:	ff 93       	push	r31
	if (p_NTI[0]!=0)
 944:	e0 91 66 00 	lds	r30, 0x0066	; 0x800066 <p_NTI>
 948:	f0 91 67 00 	lds	r31, 0x0067	; 0x800067 <p_NTI+0x1>
 94c:	30 97       	sbiw	r30, 0x00	; 0
 94e:	09 f0       	breq	.+2      	; 0x952 <__vector_1+0x30>
	{
		p_NTI[0]();
 950:	09 95       	icall
	}
	return;
}
 952:	ff 91       	pop	r31
 954:	ef 91       	pop	r30
 956:	bf 91       	pop	r27
 958:	af 91       	pop	r26
 95a:	9f 91       	pop	r25
 95c:	8f 91       	pop	r24
 95e:	7f 91       	pop	r23
 960:	6f 91       	pop	r22
 962:	5f 91       	pop	r21
 964:	4f 91       	pop	r20
 966:	3f 91       	pop	r19
 968:	2f 91       	pop	r18
 96a:	0f 90       	pop	r0
 96c:	0f be       	out	0x3f, r0	; 63
 96e:	0f 90       	pop	r0
 970:	1f 90       	pop	r1
 972:	18 95       	reti

00000974 <__vector_2>:

ISR(INT1_vect)
{
 974:	1f 92       	push	r1
 976:	0f 92       	push	r0
 978:	0f b6       	in	r0, 0x3f	; 63
 97a:	0f 92       	push	r0
 97c:	11 24       	eor	r1, r1
 97e:	2f 93       	push	r18
 980:	3f 93       	push	r19
 982:	4f 93       	push	r20
 984:	5f 93       	push	r21
 986:	6f 93       	push	r22
 988:	7f 93       	push	r23
 98a:	8f 93       	push	r24
 98c:	9f 93       	push	r25
 98e:	af 93       	push	r26
 990:	bf 93       	push	r27
 992:	ef 93       	push	r30
 994:	ff 93       	push	r31
	if (p_NTI[1]!=0)
 996:	e0 91 68 00 	lds	r30, 0x0068	; 0x800068 <p_NTI+0x2>
 99a:	f0 91 69 00 	lds	r31, 0x0069	; 0x800069 <p_NTI+0x3>
 99e:	30 97       	sbiw	r30, 0x00	; 0
 9a0:	09 f0       	breq	.+2      	; 0x9a4 <__vector_2+0x30>
	{
		p_NTI[1]();
 9a2:	09 95       	icall
	}
	return;
}
 9a4:	ff 91       	pop	r31
 9a6:	ef 91       	pop	r30
 9a8:	bf 91       	pop	r27
 9aa:	af 91       	pop	r26
 9ac:	9f 91       	pop	r25
 9ae:	8f 91       	pop	r24
 9b0:	7f 91       	pop	r23
 9b2:	6f 91       	pop	r22
 9b4:	5f 91       	pop	r21
 9b6:	4f 91       	pop	r20
 9b8:	3f 91       	pop	r19
 9ba:	2f 91       	pop	r18
 9bc:	0f 90       	pop	r0
 9be:	0f be       	out	0x3f, r0	; 63
 9c0:	0f 90       	pop	r0
 9c2:	1f 90       	pop	r1
 9c4:	18 95       	reti

000009c6 <__vector_3>:

ISR(INT2_vect)
{
 9c6:	1f 92       	push	r1
 9c8:	0f 92       	push	r0
 9ca:	0f b6       	in	r0, 0x3f	; 63
 9cc:	0f 92       	push	r0
 9ce:	11 24       	eor	r1, r1
 9d0:	2f 93       	push	r18
 9d2:	3f 93       	push	r19
 9d4:	4f 93       	push	r20
 9d6:	5f 93       	push	r21
 9d8:	6f 93       	push	r22
 9da:	7f 93       	push	r23
 9dc:	8f 93       	push	r24
 9de:	9f 93       	push	r25
 9e0:	af 93       	push	r26
 9e2:	bf 93       	push	r27
 9e4:	ef 93       	push	r30
 9e6:	ff 93       	push	r31
	if (p_NTI[2]!=0) 
 9e8:	e0 91 6a 00 	lds	r30, 0x006A	; 0x80006a <p_NTI+0x4>
 9ec:	f0 91 6b 00 	lds	r31, 0x006B	; 0x80006b <p_NTI+0x5>
 9f0:	30 97       	sbiw	r30, 0x00	; 0
 9f2:	09 f0       	breq	.+2      	; 0x9f6 <__vector_3+0x30>
	{
		p_NTI[2]();
 9f4:	09 95       	icall
	}
	return;
 9f6:	ff 91       	pop	r31
 9f8:	ef 91       	pop	r30
 9fa:	bf 91       	pop	r27
 9fc:	af 91       	pop	r26
 9fe:	9f 91       	pop	r25
 a00:	8f 91       	pop	r24
 a02:	7f 91       	pop	r23
 a04:	6f 91       	pop	r22
 a06:	5f 91       	pop	r21
 a08:	4f 91       	pop	r20
 a0a:	3f 91       	pop	r19
 a0c:	2f 91       	pop	r18
 a0e:	0f 90       	pop	r0
 a10:	0f be       	out	0x3f, r0	; 63
 a12:	0f 90       	pop	r0
 a14:	1f 90       	pop	r1
 a16:	18 95       	reti

00000a18 <I2C_init>:
#include "C:\Users\USER\Desktop\nti repo\NTI\NTI_AVR\NTI_AVR\MCAL\IIC\IIC_Interface.h"
#include "C:\Users\USER\Desktop\nti repo\NTI\NTI_AVR\NTI_AVR\utils.h"
#include "C:\Users\USER\Desktop\nti repo\NTI\NTI_AVR\NTI_AVR\HAL\LCD\lcd.h"
void I2C_init (i2c_prescaler_t prescaler,SCL_t scl)
{
	TWSR&=0xFC;
 a18:	91 b1       	in	r25, 0x01	; 1
 a1a:	9c 7f       	andi	r25, 0xFC	; 252
 a1c:	91 b9       	out	0x01, r25	; 1
	u8 TWPS=(u8)prescaler;
	TWSR|=TWPS;
 a1e:	91 b1       	in	r25, 0x01	; 1
 a20:	98 2b       	or	r25, r24
 a22:	91 b9       	out	0x01, r25	; 1
	switch (scl)
 a24:	66 23       	and	r22, r22
 a26:	19 f0       	breq	.+6      	; 0xa2e <I2C_init+0x16>
 a28:	61 30       	cpi	r22, 0x01	; 1
 a2a:	a9 f0       	breq	.+42     	; 0xa56 <I2C_init+0x3e>
 a2c:	08 95       	ret
	{
		case SCL_100: switch(TWPS)
 a2e:	81 30       	cpi	r24, 0x01	; 1
 a30:	49 f0       	breq	.+18     	; 0xa44 <I2C_init+0x2c>
 a32:	28 f0       	brcs	.+10     	; 0xa3e <I2C_init+0x26>
 a34:	82 30       	cpi	r24, 0x02	; 2
 a36:	49 f0       	breq	.+18     	; 0xa4a <I2C_init+0x32>
 a38:	83 30       	cpi	r24, 0x03	; 3
 a3a:	51 f0       	breq	.+20     	; 0xa50 <I2C_init+0x38>
 a3c:	08 95       	ret
		{
			case 0: TWBR=TWBR_OF_SCL(100,1);break;
 a3e:	88 e7       	ldi	r24, 0x78	; 120
 a40:	80 b9       	out	0x00, r24	; 0
 a42:	08 95       	ret
			case 1: TWBR=TWBR_OF_SCL(100,4);break;
 a44:	8e e1       	ldi	r24, 0x1E	; 30
 a46:	80 b9       	out	0x00, r24	; 0
 a48:	08 95       	ret
			case 2: TWBR=TWBR_OF_SCL(100,16);break;
 a4a:	87 e8       	ldi	r24, 0x87	; 135
 a4c:	80 b9       	out	0x00, r24	; 0
 a4e:	08 95       	ret
			case 3: TWBR=TWBR_OF_SCL(100,64);break;
 a50:	81 ee       	ldi	r24, 0xE1	; 225
 a52:	80 b9       	out	0x00, r24	; 0
 a54:	08 95       	ret
		}break;
		case SCL_400: switch(TWPS)
 a56:	81 30       	cpi	r24, 0x01	; 1
 a58:	49 f0       	breq	.+18     	; 0xa6c <I2C_init+0x54>
 a5a:	28 f0       	brcs	.+10     	; 0xa66 <I2C_init+0x4e>
 a5c:	82 30       	cpi	r24, 0x02	; 2
 a5e:	49 f0       	breq	.+18     	; 0xa72 <I2C_init+0x5a>
 a60:	83 30       	cpi	r24, 0x03	; 3
 a62:	51 f0       	breq	.+20     	; 0xa78 <I2C_init+0x60>
 a64:	08 95       	ret
		{
			case 0: TWBR=TWBR_OF_SCL(400,1);break;
 a66:	88 e1       	ldi	r24, 0x18	; 24
 a68:	80 b9       	out	0x00, r24	; 0
 a6a:	08 95       	ret
			case 1: TWBR=TWBR_OF_SCL(400,4);break;
 a6c:	86 e8       	ldi	r24, 0x86	; 134
 a6e:	80 b9       	out	0x00, r24	; 0
 a70:	08 95       	ret
			case 2: TWBR=TWBR_OF_SCL(400,16);break;
 a72:	81 ee       	ldi	r24, 0xE1	; 225
 a74:	80 b9       	out	0x00, r24	; 0
 a76:	08 95       	ret
			case 3: TWBR=TWBR_OF_SCL(400,64);break;
 a78:	88 e3       	ldi	r24, 0x38	; 56
 a7a:	80 b9       	out	0x00, r24	; 0
 a7c:	08 95       	ret

00000a7e <I2C_sendByte>:
	}
}

void I2C_sendByte(u8 copy_u8data)
{
	TWDR = copy_u8data;
 a7e:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
 a80:	84 ea       	ldi	r24, 0xA4	; 164
 a82:	86 bf       	out	0x36, r24	; 54
	while (!(TWCR & (1<<TWINT)));
 a84:	06 b6       	in	r0, 0x36	; 54
 a86:	07 fe       	sbrs	r0, 7
 a88:	fd cf       	rjmp	.-6      	; 0xa84 <I2C_sendByte+0x6>
}
 a8a:	08 95       	ret

00000a8c <I2C_sendStart>:

void I2C_sendStart(void)
{
	TWCR = (1<<TWINT)|(1<<TWSTA)| (1<<TWEN);
 a8c:	84 ea       	ldi	r24, 0xA4	; 164
 a8e:	86 bf       	out	0x36, r24	; 54
	while(READ_BIT(TWCR, TWINT) == 0);
 a90:	06 b6       	in	r0, 0x36	; 54
 a92:	07 fe       	sbrs	r0, 7
 a94:	fd cf       	rjmp	.-6      	; 0xa90 <I2C_sendStart+0x4>

}
 a96:	08 95       	ret

00000a98 <I2C_sendStop>:

void I2C_sendStop(void)
{
	TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO);
 a98:	84 e9       	ldi	r24, 0x94	; 148
 a9a:	86 bf       	out	0x36, r24	; 54
	while (TWCR & (1 << TWSTO));
 a9c:	06 b6       	in	r0, 0x36	; 54
 a9e:	04 fc       	sbrc	r0, 4
 aa0:	fd cf       	rjmp	.-6      	; 0xa9c <I2C_sendStop+0x4>

}
 aa2:	08 95       	ret

00000aa4 <I2C_recieveByte_ACK>:
void I2C_recieveByte_ACK(u8* ptr)
{
	TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWEA);
 aa4:	24 ec       	ldi	r18, 0xC4	; 196
 aa6:	26 bf       	out	0x36, r18	; 54

	while(READ_BIT(TWCR, TWINT) == 0);
 aa8:	06 b6       	in	r0, 0x36	; 54
 aaa:	07 fe       	sbrs	r0, 7
 aac:	fd cf       	rjmp	.-6      	; 0xaa8 <I2C_recieveByte_ACK+0x4>
	*ptr = TWDR;
 aae:	23 b1       	in	r18, 0x03	; 3
 ab0:	fc 01       	movw	r30, r24
 ab2:	20 83       	st	Z, r18
 ab4:	08 95       	ret

00000ab6 <I2C_RECIEVENoACK>:
}
void I2C_RECIEVENoACK(u8* ptr)
{
	TWCR = (1<<TWINT)|(1<<TWEN);
 ab6:	24 e8       	ldi	r18, 0x84	; 132
 ab8:	26 bf       	out	0x36, r18	; 54

	while(READ_BIT(TWCR, TWINT) == 0);
 aba:	06 b6       	in	r0, 0x36	; 54
 abc:	07 fe       	sbrs	r0, 7
 abe:	fd cf       	rjmp	.-6      	; 0xaba <I2C_RECIEVENoACK+0x4>

	*ptr = TWDR;
 ac0:	23 b1       	in	r18, 0x03	; 3
 ac2:	fc 01       	movw	r30, r24
 ac4:	20 83       	st	Z, r18
 ac6:	08 95       	ret

00000ac8 <I2C_getStatus>:
}

void I2C_getStatus(u8* status )
{
 ac8:	fc 01       	movw	r30, r24
	*status =(TWSR& 0xF8);
 aca:	91 b1       	in	r25, 0x01	; 1
 acc:	98 7f       	andi	r25, 0xF8	; 248
 ace:	90 83       	st	Z, r25
 ad0:	08 95       	ret

00000ad2 <__vector_11>:
	u32 t_total=ton+t_off;
	u8 duty =((u32)ton *100) /(u32)t_total;

	return duty;
	
}
 ad2:	1f 92       	push	r1
 ad4:	0f 92       	push	r0
 ad6:	0f b6       	in	r0, 0x3f	; 63
 ad8:	0f 92       	push	r0
 ada:	11 24       	eor	r1, r1
 adc:	2f 93       	push	r18
 ade:	3f 93       	push	r19
 ae0:	4f 93       	push	r20
 ae2:	5f 93       	push	r21
 ae4:	6f 93       	push	r22
 ae6:	7f 93       	push	r23
 ae8:	8f 93       	push	r24
 aea:	9f 93       	push	r25
 aec:	af 93       	push	r26
 aee:	bf 93       	push	r27
 af0:	ef 93       	push	r30
 af2:	ff 93       	push	r31
 af4:	e0 91 76 00 	lds	r30, 0x0076	; 0x800076 <OVF_ptr>
 af8:	f0 91 77 00 	lds	r31, 0x0077	; 0x800077 <OVF_ptr+0x1>
 afc:	30 97       	sbiw	r30, 0x00	; 0
 afe:	09 f0       	breq	.+2      	; 0xb02 <__vector_11+0x30>
 b00:	09 95       	icall
 b02:	ff 91       	pop	r31
 b04:	ef 91       	pop	r30
 b06:	bf 91       	pop	r27
 b08:	af 91       	pop	r26
 b0a:	9f 91       	pop	r25
 b0c:	8f 91       	pop	r24
 b0e:	7f 91       	pop	r23
 b10:	6f 91       	pop	r22
 b12:	5f 91       	pop	r21
 b14:	4f 91       	pop	r20
 b16:	3f 91       	pop	r19
 b18:	2f 91       	pop	r18
 b1a:	0f 90       	pop	r0
 b1c:	0f be       	out	0x3f, r0	; 63
 b1e:	0f 90       	pop	r0
 b20:	1f 90       	pop	r1
 b22:	18 95       	reti

00000b24 <__vector_10>:
 b24:	1f 92       	push	r1
 b26:	0f 92       	push	r0
 b28:	0f b6       	in	r0, 0x3f	; 63
 b2a:	0f 92       	push	r0
 b2c:	11 24       	eor	r1, r1
 b2e:	2f 93       	push	r18
 b30:	3f 93       	push	r19
 b32:	4f 93       	push	r20
 b34:	5f 93       	push	r21
 b36:	6f 93       	push	r22
 b38:	7f 93       	push	r23
 b3a:	8f 93       	push	r24
 b3c:	9f 93       	push	r25
 b3e:	af 93       	push	r26
 b40:	bf 93       	push	r27
 b42:	ef 93       	push	r30
 b44:	ff 93       	push	r31
 b46:	e0 91 74 00 	lds	r30, 0x0074	; 0x800074 <CM_ptr>
 b4a:	f0 91 75 00 	lds	r31, 0x0075	; 0x800075 <CM_ptr+0x1>
 b4e:	30 97       	sbiw	r30, 0x00	; 0
 b50:	09 f0       	breq	.+2      	; 0xb54 <__vector_10+0x30>
 b52:	09 95       	icall
 b54:	ff 91       	pop	r31
 b56:	ef 91       	pop	r30
 b58:	bf 91       	pop	r27
 b5a:	af 91       	pop	r26
 b5c:	9f 91       	pop	r25
 b5e:	8f 91       	pop	r24
 b60:	7f 91       	pop	r23
 b62:	6f 91       	pop	r22
 b64:	5f 91       	pop	r21
 b66:	4f 91       	pop	r20
 b68:	3f 91       	pop	r19
 b6a:	2f 91       	pop	r18
 b6c:	0f 90       	pop	r0
 b6e:	0f be       	out	0x3f, r0	; 63
 b70:	0f 90       	pop	r0
 b72:	1f 90       	pop	r1
 b74:	18 95       	reti

00000b76 <__vector_9>:
{
	Timer1_ICU_Fptr=LocalFptr;
}

ISR(TIMER1_OVF_vect)
{
 b76:	1f 92       	push	r1
 b78:	0f 92       	push	r0
 b7a:	0f b6       	in	r0, 0x3f	; 63
 b7c:	0f 92       	push	r0
 b7e:	11 24       	eor	r1, r1
 b80:	2f 93       	push	r18
 b82:	3f 93       	push	r19
 b84:	4f 93       	push	r20
 b86:	5f 93       	push	r21
 b88:	6f 93       	push	r22
 b8a:	7f 93       	push	r23
 b8c:	8f 93       	push	r24
 b8e:	9f 93       	push	r25
 b90:	af 93       	push	r26
 b92:	bf 93       	push	r27
 b94:	ef 93       	push	r30
 b96:	ff 93       	push	r31
	if(Timer1_OVF_Fptr!=0)
 b98:	e0 91 72 00 	lds	r30, 0x0072	; 0x800072 <Timer1_OVF_Fptr>
 b9c:	f0 91 73 00 	lds	r31, 0x0073	; 0x800073 <Timer1_OVF_Fptr+0x1>
 ba0:	30 97       	sbiw	r30, 0x00	; 0
 ba2:	09 f0       	breq	.+2      	; 0xba6 <__vector_9+0x30>
	{
		Timer1_OVF_Fptr();
 ba4:	09 95       	icall
	}
}
 ba6:	ff 91       	pop	r31
 ba8:	ef 91       	pop	r30
 baa:	bf 91       	pop	r27
 bac:	af 91       	pop	r26
 bae:	9f 91       	pop	r25
 bb0:	8f 91       	pop	r24
 bb2:	7f 91       	pop	r23
 bb4:	6f 91       	pop	r22
 bb6:	5f 91       	pop	r21
 bb8:	4f 91       	pop	r20
 bba:	3f 91       	pop	r19
 bbc:	2f 91       	pop	r18
 bbe:	0f 90       	pop	r0
 bc0:	0f be       	out	0x3f, r0	; 63
 bc2:	0f 90       	pop	r0
 bc4:	1f 90       	pop	r1
 bc6:	18 95       	reti

00000bc8 <__vector_7>:
ISR(TIMER1_OCA_vect)
{
 bc8:	1f 92       	push	r1
 bca:	0f 92       	push	r0
 bcc:	0f b6       	in	r0, 0x3f	; 63
 bce:	0f 92       	push	r0
 bd0:	11 24       	eor	r1, r1
 bd2:	2f 93       	push	r18
 bd4:	3f 93       	push	r19
 bd6:	4f 93       	push	r20
 bd8:	5f 93       	push	r21
 bda:	6f 93       	push	r22
 bdc:	7f 93       	push	r23
 bde:	8f 93       	push	r24
 be0:	9f 93       	push	r25
 be2:	af 93       	push	r26
 be4:	bf 93       	push	r27
 be6:	ef 93       	push	r30
 be8:	ff 93       	push	r31
	if(Timer1_OCA_Fptr!=0)
 bea:	e0 91 70 00 	lds	r30, 0x0070	; 0x800070 <Timer1_OCA_Fptr>
 bee:	f0 91 71 00 	lds	r31, 0x0071	; 0x800071 <Timer1_OCA_Fptr+0x1>
 bf2:	30 97       	sbiw	r30, 0x00	; 0
 bf4:	09 f0       	breq	.+2      	; 0xbf8 <__vector_7+0x30>
	{
		Timer1_OCA_Fptr();
 bf6:	09 95       	icall
	}
}
 bf8:	ff 91       	pop	r31
 bfa:	ef 91       	pop	r30
 bfc:	bf 91       	pop	r27
 bfe:	af 91       	pop	r26
 c00:	9f 91       	pop	r25
 c02:	8f 91       	pop	r24
 c04:	7f 91       	pop	r23
 c06:	6f 91       	pop	r22
 c08:	5f 91       	pop	r21
 c0a:	4f 91       	pop	r20
 c0c:	3f 91       	pop	r19
 c0e:	2f 91       	pop	r18
 c10:	0f 90       	pop	r0
 c12:	0f be       	out	0x3f, r0	; 63
 c14:	0f 90       	pop	r0
 c16:	1f 90       	pop	r1
 c18:	18 95       	reti

00000c1a <__vector_8>:
ISR(TIMER1_OCB_vect)
{
 c1a:	1f 92       	push	r1
 c1c:	0f 92       	push	r0
 c1e:	0f b6       	in	r0, 0x3f	; 63
 c20:	0f 92       	push	r0
 c22:	11 24       	eor	r1, r1
 c24:	2f 93       	push	r18
 c26:	3f 93       	push	r19
 c28:	4f 93       	push	r20
 c2a:	5f 93       	push	r21
 c2c:	6f 93       	push	r22
 c2e:	7f 93       	push	r23
 c30:	8f 93       	push	r24
 c32:	9f 93       	push	r25
 c34:	af 93       	push	r26
 c36:	bf 93       	push	r27
 c38:	ef 93       	push	r30
 c3a:	ff 93       	push	r31
	if(Timer1_OCB_Fptr!=0)
 c3c:	e0 91 6e 00 	lds	r30, 0x006E	; 0x80006e <Timer1_OCB_Fptr>
 c40:	f0 91 6f 00 	lds	r31, 0x006F	; 0x80006f <Timer1_OCB_Fptr+0x1>
 c44:	30 97       	sbiw	r30, 0x00	; 0
 c46:	09 f0       	breq	.+2      	; 0xc4a <__vector_8+0x30>
	{
		Timer1_OCB_Fptr();
 c48:	09 95       	icall
	}
}
 c4a:	ff 91       	pop	r31
 c4c:	ef 91       	pop	r30
 c4e:	bf 91       	pop	r27
 c50:	af 91       	pop	r26
 c52:	9f 91       	pop	r25
 c54:	8f 91       	pop	r24
 c56:	7f 91       	pop	r23
 c58:	6f 91       	pop	r22
 c5a:	5f 91       	pop	r21
 c5c:	4f 91       	pop	r20
 c5e:	3f 91       	pop	r19
 c60:	2f 91       	pop	r18
 c62:	0f 90       	pop	r0
 c64:	0f be       	out	0x3f, r0	; 63
 c66:	0f 90       	pop	r0
 c68:	1f 90       	pop	r1
 c6a:	18 95       	reti

00000c6c <__vector_6>:
ISR(TIMER1_ICU_vect)
{
 c6c:	1f 92       	push	r1
 c6e:	0f 92       	push	r0
 c70:	0f b6       	in	r0, 0x3f	; 63
 c72:	0f 92       	push	r0
 c74:	11 24       	eor	r1, r1
 c76:	2f 93       	push	r18
 c78:	3f 93       	push	r19
 c7a:	4f 93       	push	r20
 c7c:	5f 93       	push	r21
 c7e:	6f 93       	push	r22
 c80:	7f 93       	push	r23
 c82:	8f 93       	push	r24
 c84:	9f 93       	push	r25
 c86:	af 93       	push	r26
 c88:	bf 93       	push	r27
 c8a:	ef 93       	push	r30
 c8c:	ff 93       	push	r31
	if(Timer1_ICU_Fptr!=0)
 c8e:	e0 91 6c 00 	lds	r30, 0x006C	; 0x80006c <Timer1_ICU_Fptr>
 c92:	f0 91 6d 00 	lds	r31, 0x006D	; 0x80006d <Timer1_ICU_Fptr+0x1>
 c96:	30 97       	sbiw	r30, 0x00	; 0
 c98:	09 f0       	breq	.+2      	; 0xc9c <__vector_6+0x30>
	{
		Timer1_ICU_Fptr();
 c9a:	09 95       	icall
	}
}
 c9c:	ff 91       	pop	r31
 c9e:	ef 91       	pop	r30
 ca0:	bf 91       	pop	r27
 ca2:	af 91       	pop	r26
 ca4:	9f 91       	pop	r25
 ca6:	8f 91       	pop	r24
 ca8:	7f 91       	pop	r23
 caa:	6f 91       	pop	r22
 cac:	5f 91       	pop	r21
 cae:	4f 91       	pop	r20
 cb0:	3f 91       	pop	r19
 cb2:	2f 91       	pop	r18
 cb4:	0f 90       	pop	r0
 cb6:	0f be       	out	0x3f, r0	; 63
 cb8:	0f 90       	pop	r0
 cba:	1f 90       	pop	r1
 cbc:	18 95       	reti

00000cbe <__vector_13>:
	{
		Uart_TX_Fptr=LocalFPtr;
	}
}
ISR(UART_RX_vect)
{
 cbe:	1f 92       	push	r1
 cc0:	0f 92       	push	r0
 cc2:	0f b6       	in	r0, 0x3f	; 63
 cc4:	0f 92       	push	r0
 cc6:	11 24       	eor	r1, r1
 cc8:	2f 93       	push	r18
 cca:	3f 93       	push	r19
 ccc:	4f 93       	push	r20
 cce:	5f 93       	push	r21
 cd0:	6f 93       	push	r22
 cd2:	7f 93       	push	r23
 cd4:	8f 93       	push	r24
 cd6:	9f 93       	push	r25
 cd8:	af 93       	push	r26
 cda:	bf 93       	push	r27
 cdc:	ef 93       	push	r30
 cde:	ff 93       	push	r31
	
	if (Uart_RX_Fptr!=0)
 ce0:	e0 91 7a 00 	lds	r30, 0x007A	; 0x80007a <Uart_RX_Fptr>
 ce4:	f0 91 7b 00 	lds	r31, 0x007B	; 0x80007b <Uart_RX_Fptr+0x1>
 ce8:	30 97       	sbiw	r30, 0x00	; 0
 cea:	09 f0       	breq	.+2      	; 0xcee <__vector_13+0x30>
	{
		Uart_RX_Fptr();
 cec:	09 95       	icall
	}
}
 cee:	ff 91       	pop	r31
 cf0:	ef 91       	pop	r30
 cf2:	bf 91       	pop	r27
 cf4:	af 91       	pop	r26
 cf6:	9f 91       	pop	r25
 cf8:	8f 91       	pop	r24
 cfa:	7f 91       	pop	r23
 cfc:	6f 91       	pop	r22
 cfe:	5f 91       	pop	r21
 d00:	4f 91       	pop	r20
 d02:	3f 91       	pop	r19
 d04:	2f 91       	pop	r18
 d06:	0f 90       	pop	r0
 d08:	0f be       	out	0x3f, r0	; 63
 d0a:	0f 90       	pop	r0
 d0c:	1f 90       	pop	r1
 d0e:	18 95       	reti

00000d10 <__vector_15>:
ISR (UART_TX_vect)
{
 d10:	1f 92       	push	r1
 d12:	0f 92       	push	r0
 d14:	0f b6       	in	r0, 0x3f	; 63
 d16:	0f 92       	push	r0
 d18:	11 24       	eor	r1, r1
 d1a:	2f 93       	push	r18
 d1c:	3f 93       	push	r19
 d1e:	4f 93       	push	r20
 d20:	5f 93       	push	r21
 d22:	6f 93       	push	r22
 d24:	7f 93       	push	r23
 d26:	8f 93       	push	r24
 d28:	9f 93       	push	r25
 d2a:	af 93       	push	r26
 d2c:	bf 93       	push	r27
 d2e:	ef 93       	push	r30
 d30:	ff 93       	push	r31
	if (Uart_TX_Fptr!=0)
 d32:	e0 91 78 00 	lds	r30, 0x0078	; 0x800078 <Uart_TX_Fptr>
 d36:	f0 91 79 00 	lds	r31, 0x0079	; 0x800079 <Uart_TX_Fptr+0x1>
 d3a:	30 97       	sbiw	r30, 0x00	; 0
 d3c:	09 f0       	breq	.+2      	; 0xd40 <__vector_15+0x30>
	{
		Uart_TX_Fptr();
 d3e:	09 95       	icall
	}
	
 d40:	ff 91       	pop	r31
 d42:	ef 91       	pop	r30
 d44:	bf 91       	pop	r27
 d46:	af 91       	pop	r26
 d48:	9f 91       	pop	r25
 d4a:	8f 91       	pop	r24
 d4c:	7f 91       	pop	r23
 d4e:	6f 91       	pop	r22
 d50:	5f 91       	pop	r21
 d52:	4f 91       	pop	r20
 d54:	3f 91       	pop	r19
 d56:	2f 91       	pop	r18
 d58:	0f 90       	pop	r0
 d5a:	0f be       	out	0x3f, r0	; 63
 d5c:	0f 90       	pop	r0
 d5e:	1f 90       	pop	r1
 d60:	18 95       	reti

00000d62 <__udivmodsi4>:
 d62:	a1 e2       	ldi	r26, 0x21	; 33
 d64:	1a 2e       	mov	r1, r26
 d66:	aa 1b       	sub	r26, r26
 d68:	bb 1b       	sub	r27, r27
 d6a:	fd 01       	movw	r30, r26
 d6c:	0d c0       	rjmp	.+26     	; 0xd88 <__udivmodsi4_ep>

00000d6e <__udivmodsi4_loop>:
 d6e:	aa 1f       	adc	r26, r26
 d70:	bb 1f       	adc	r27, r27
 d72:	ee 1f       	adc	r30, r30
 d74:	ff 1f       	adc	r31, r31
 d76:	a2 17       	cp	r26, r18
 d78:	b3 07       	cpc	r27, r19
 d7a:	e4 07       	cpc	r30, r20
 d7c:	f5 07       	cpc	r31, r21
 d7e:	20 f0       	brcs	.+8      	; 0xd88 <__udivmodsi4_ep>
 d80:	a2 1b       	sub	r26, r18
 d82:	b3 0b       	sbc	r27, r19
 d84:	e4 0b       	sbc	r30, r20
 d86:	f5 0b       	sbc	r31, r21

00000d88 <__udivmodsi4_ep>:
 d88:	66 1f       	adc	r22, r22
 d8a:	77 1f       	adc	r23, r23
 d8c:	88 1f       	adc	r24, r24
 d8e:	99 1f       	adc	r25, r25
 d90:	1a 94       	dec	r1
 d92:	69 f7       	brne	.-38     	; 0xd6e <__udivmodsi4_loop>
 d94:	60 95       	com	r22
 d96:	70 95       	com	r23
 d98:	80 95       	com	r24
 d9a:	90 95       	com	r25
 d9c:	9b 01       	movw	r18, r22
 d9e:	ac 01       	movw	r20, r24
 da0:	bd 01       	movw	r22, r26
 da2:	cf 01       	movw	r24, r30
 da4:	08 95       	ret

00000da6 <__divmodsi4>:
 da6:	05 2e       	mov	r0, r21
 da8:	97 fb       	bst	r25, 7
 daa:	1e f4       	brtc	.+6      	; 0xdb2 <__divmodsi4+0xc>
 dac:	00 94       	com	r0
 dae:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <__negsi2>
 db2:	57 fd       	sbrc	r21, 7
 db4:	07 d0       	rcall	.+14     	; 0xdc4 <__divmodsi4_neg2>
 db6:	0e 94 b1 06 	call	0xd62	; 0xd62 <__udivmodsi4>
 dba:	07 fc       	sbrc	r0, 7
 dbc:	03 d0       	rcall	.+6      	; 0xdc4 <__divmodsi4_neg2>
 dbe:	4e f4       	brtc	.+18     	; 0xdd2 <__divmodsi4_exit>
 dc0:	0c 94 ea 06 	jmp	0xdd4	; 0xdd4 <__negsi2>

00000dc4 <__divmodsi4_neg2>:
 dc4:	50 95       	com	r21
 dc6:	40 95       	com	r20
 dc8:	30 95       	com	r19
 dca:	21 95       	neg	r18
 dcc:	3f 4f       	sbci	r19, 0xFF	; 255
 dce:	4f 4f       	sbci	r20, 0xFF	; 255
 dd0:	5f 4f       	sbci	r21, 0xFF	; 255

00000dd2 <__divmodsi4_exit>:
 dd2:	08 95       	ret

00000dd4 <__negsi2>:
 dd4:	90 95       	com	r25
 dd6:	80 95       	com	r24
 dd8:	70 95       	com	r23
 dda:	61 95       	neg	r22
 ddc:	7f 4f       	sbci	r23, 0xFF	; 255
 dde:	8f 4f       	sbci	r24, 0xFF	; 255
 de0:	9f 4f       	sbci	r25, 0xFF	; 255
 de2:	08 95       	ret

00000de4 <__tablejump2__>:
 de4:	ee 0f       	add	r30, r30
 de6:	ff 1f       	adc	r31, r31
 de8:	05 90       	lpm	r0, Z+
 dea:	f4 91       	lpm	r31, Z
 dec:	e0 2d       	mov	r30, r0
 dee:	09 94       	ijmp

00000df0 <_exit>:
 df0:	f8 94       	cli

00000df2 <__stop_program>:
 df2:	ff cf       	rjmp	.-2      	; 0xdf2 <__stop_program>
